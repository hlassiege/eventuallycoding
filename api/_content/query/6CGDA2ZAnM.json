{"_path":"/articles/2010/11/28/introduction-aux-tests-unitaires-et-aux-bouchons-en-c-2","_dir":"28","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Introduction aux tests unitaires et aux bouchons en C#","description":"Par définition (Cf. [Wikipédia](http://fr.wikipedia.org/wiki/Test_unitaire) ) un test unitaire est un procédé permettant de s'assurer du fonctionnemen...","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Par définition (Cf. "},{"type":"element","tag":"a","props":{"href":"http://fr.wikipedia.org/wiki/Test_unitaire","rel":["nofollow"]},"children":[{"type":"text","value":"Wikipédia"}]},{"type":"text","value":" ) un test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme (appelée « unité » ou « module »)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test est dit "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"unitaire"}]},{"type":"text","value":" s'il ne fait pas appel à d'autres ressources que la classe testé. Un test unitaire n'utilise donc pas de base de données, de socket, MQ series etc... à l'inverse d'un test d'intégration."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test d'"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"intégration"}]},{"type":"text","value":" est donc par extension un test qui peut utiliser des ressources externes : bases de données par exemple."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Voyons ce que ça donne en C#."}]},{"type":"element","tag":"h2","props":{"id":"écriture-dun-premier-test"},"children":[{"type":"text","value":"Écriture d'un premier test"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Par convention, une classe de test correspond généralement aux tests d'une classe de votre code."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Exemple"}]},{"type":"text","value":" :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"votre classe : "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"EmailAdressValidator"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class  EmailAddressValidator\n{\nprivate DomainValidator domainValidator;"}]},{"type":"element","tag":"code","props":{"code":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n        return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n    ...\npublic bool CheckDomainExists(string domain)\n{\n        return  domainValidator.Exists(domain);\n}\n...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n        return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n    ...\npublic bool CheckDomainExists(string domain)\n{\n        return  domainValidator.Exists(domain);\n}\n...\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"la classe de test : "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"EmailAdressValidatorTest"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Une classe de test comporte un stéréotype TestFixture, les méthodes de test ont un stéréotype Test."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[TestFixture]\npublic class EmailValidatorTest\n{\nEmailAddressValidator EAV;"}]},{"type":"element","tag":"code","props":{"code":"\\[SetUp\\]\npublic void SetUp()\n{\n    EAV = new EmailAddressValidator ();\n}\n\n\\[TearDown\\]\npublic void TearDown()\n{\n    EVA.Clean();\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[SetUp\\]\npublic void SetUp()\n{\n    EAV = new EmailAddressValidator ();\n}\n\n\\[TearDown\\]\npublic void TearDown()\n{\n    EVA.Clean();\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[Test]\npublic void TestEmailSyntaxArobas()\n{\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\""},{"type":"element","tag":"a","props":{"href":"mailto:Nom@entreprise.com"},"children":[{"type":"text","value":"Nom@entreprise.com"}]},{"type":"text","value":"\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n}\n}"}]},{"type":"element","tag":"h2","props":{"id":"différentes-assertions"},"children":[{"type":"text","value":"Différentes assertions"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans un test, on cherche toujours à vérifier un comportement. On utilise donc des assertions, ces assertions définissent le comportement attendu."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En francais, une assertion est un énoncé considéré comme vrai."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pour un test unitaire, il s'agit d'une expression qui doit être vrai pour que le test réussisse."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NUnit et MBunit utilise une classe statique "},{"type":"element","tag":"a","props":{"href":"http://gallio.org/api/html/AllMembers_T_MbUnit_Framework_Assert.htm","rel":["nofollow"]},"children":[{"type":"text","value":"Assert"}]},{"type":"text","value":" pour les assertions :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cette classe "},{"type":"element","tag":"a","props":{"href":"http://gallio.org/api/html/AllMembers_T_MbUnit_Framework_Assert.htm","rel":["nofollow"]},"children":[{"type":"text","value":"Assert"}]},{"type":"text","value":" va nous permettre de tester entre autre :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"l'égalité : Assert.Equals"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"le non null : Assert.IsNotNull"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"une condition Assert.IsTrue"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nmais aussi, la présence dans une plage de valeur, une égalité approximative, l'égalité des références etc..."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test comporte toujours des assertions."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// CheckEmailAdressSyntax doit renvoyer true avec le paramètre \""},{"type":"element","tag":"a","props":{"href":"mailto:Nom@entreprise.com"},"children":[{"type":"text","value":"Nom@entreprise.com"}]},{"type":"text","value":"\"\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\""},{"type":"element","tag":"a","props":{"href":"mailto:Nom@entreprise.com"},"children":[{"type":"text","value":"Nom@entreprise.com"}]},{"type":"text","value":"\"));"}]},{"type":"element","tag":"h2","props":{"id":"setupteardown"},"children":[{"type":"text","value":"Setup/TearDown"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Il est parfois nécessaire d'effectuer des opérations avant et après chaque test. Une classe peut donc définir des méthodes appelées avant et après chaque test avec les stéréotypes Setup et Teardown."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// toujours exécuté avant les tests\n[SetUp]\npublic void SetUp()\n{\nEAV = new EmailAddressValidator ();\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// toujours exécuté après les tests\n[TearDown]\npublic void TearDown()\n{\nEVA.Clean();\n}"}]},{"type":"element","tag":"h2","props":{"id":"la-couverture-de-code"},"children":[{"type":"text","value":"La couverture de code"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"couverture de code"}]},{"type":"text","value":" est une métrique utilisée en génie logiciel pour décrire le taux de code source "},{"type":"element","tag":"a","props":{"href":"http://fr.wikipedia.org/wiki/Code_source","rel":["nofollow"]},"children":[{"type":"text","value":"http://fr.wikipedia.org/wiki/Code_source"}]},{"type":"text","value":" testé d'un programme. Ceci permet de mesurer la qualité des tests effectués."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En .NET on utilise "},{"type":"element","tag":"a","props":{"href":"http://www.ncover.com/","rel":["nofollow"]},"children":[{"type":"text","value":"NCover"}]},{"type":"text","value":" pour mesurer cette couverture de code. "},{"type":"element","tag":"a","props":{"href":"http://www.ncover.com/","rel":["nofollow"]},"children":[{"type":"text","value":"NCover"}]},{"type":"text","value":" va calculer à partir des tests joués et du code initial l'ensemble des chemins qui ont été parcourus et fournir un pourcentage du code parcouru par rapport au code non parcouru."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ci-dessous, un exemple des rapports proposés par NCover :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"XXXX"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans les tests précédents, NCover remarque que l'on ne passe pas par "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"CheckDomainExists"}]},{"type":"text","value":" que l'on verra plus bas sur cette page. De plus le test sur la nullité de la chaine entrée n'est jamais évalué à true :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"if(emailAddress == null )\n{\nthrow new NullReferenceException();\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test avec une chaine null ferait remonter la couverture de code."}]},{"type":"element","tag":"h2","props":{"id":"test-paramétré"},"children":[{"type":"text","value":"Test paramétré"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans le test précédent, on réécrit x fois la même ligne pour tester avec des paramètres différents :"}]},{"type":"element","tag":"code","props":{"code":"  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Premier défaut à cette méthode :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"il est conseillé d'avoir une assertion par méthode de test, ca permet d'être sur que tout les cas de test sont joués (sinon la première erreur empêche l'execution des autres tests)."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"code","props":{"code":"\\[Test\\]\npublic void TestInvalidEmailSyntaxWithTwoArobas()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n}\n\n\\[Test\\]\npublic void TestInvalidEmailSyntaxWithoutName()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[Test\\]\npublic void TestInvalidEmailSyntaxWithTwoArobas()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n}\n\n\\[Test\\]\npublic void TestInvalidEmailSyntaxWithoutName()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Second défaut, on duplique le code testé. Cela aurait été plus gênant avec un code sur plusieurs lignes."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Solution :"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nPour éviter de réécrire x fois le même test avec des paramètres différents, on va utiliser des tests paramétrés :"}]},{"type":"element","tag":"code","props":{"code":"\\[Test\\]\n\\[Row(\"Nom@@entreprise.com\")\\]\n\\[Row(\"Nomentreprise.com\")\\]\n\\[Row(\"@entreprise.com\")\\]\n\\[Row(\"Nom@\")\\]\npublic void TestEmailSyntaxArobas(string name)\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (name));\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[Test\\]\n\\[Row(\"Nom@@entreprise.com\")\\]\n\\[Row(\"Nomentreprise.com\")\\]\n\\[Row(\"@entreprise.com\")\\]\n\\[Row(\"Nom@\")\\]\npublic void TestEmailSyntaxArobas(string name)\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (name));\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Le même test est joué 4 fois pour chaque valeur de paramètre. L'attribut Row est utilisé pour chaque paramétre et celui-ci est passé en paramètre de la méthode."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Autre exemple avec un code plus complexe :"}]},{"type":"element","tag":"code","props":{"code":"\\[Test\\]\n\\[Row(\"Milou\")\\]\n\\[Row(\"Idefix\")\\]\npublic void TestWithFakeAndRowTest(string name)\n{\n    // \"Setup\" (initialisation des objets pour le test)\n    OrderWriter orderWriter = new OrderWriter(new FakeWriter());\n    Order order = new Order() { OrderId = 7001, Pet = new Dog(name) };\n\n    // \"Execute\" (Exécution du test : écriture de l'ordre sur le système)\n    orderWriter.WriteOrder(order);\n\n    // \"State verification\" (vérification de l'état de l'objet par des assertions)\n    Assert.AreEqual(name, order.Pet.Name);\n    Assert.IsTrue(order.IsFilled);\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[Test\\]\n\\[Row(\"Milou\")\\]\n\\[Row(\"Idefix\")\\]\npublic void TestWithFakeAndRowTest(string name)\n{\n    // \"Setup\" (initialisation des objets pour le test)\n    OrderWriter orderWriter = new OrderWriter(new FakeWriter());\n    Order order = new Order() { OrderId = 7001, Pet = new Dog(name) };\n\n    // \"Execute\" (Exécution du test : écriture de l'ordre sur le système)\n    orderWriter.WriteOrder(order);\n\n    // \"State verification\" (vérification de l'état de l'objet par des assertions)\n    Assert.AreEqual(name, order.Pet.Name);\n    Assert.IsTrue(order.IsFilled);\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"le-bouchonnage"},"children":[{"type":"text","value":"Le bouchonnage"}]},{"type":"element","tag":"h3","props":{"id":"problématique"},"children":[{"type":"text","value":"Problématique"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Comme dit plus haut, un test unitaire doit être indépendant des ressources externes : base de données, file de message etc..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mais il arrive souvent que l'on utilise ces ressources dans les classes testées."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class  EmailAddressValidator\n{\nDomainValidator domainValidator;"}]},{"type":"element","tag":"code","props":{"code":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}...\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ici le DomainValidator fait appel à un service web pour vérifier l'existence d'un nom de domaine. Le test unitaire de la méthode CheckDomainExists pose donc problème."}]},{"type":"element","tag":"h3","props":{"id":"solution"},"children":[{"type":"text","value":"Solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La solution consiste à utiliser un bouchon à la place du DomainValidator."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pour cela, un peu de remaniement de code est nécessaire ("},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"refactoring"}]},{"type":"text","value":") :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"l'objet DomainValidator n'est plus instancié dans le constructeur mais injecté par constructeur ou par mutateur (propriété)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"On utilise une interface à la place de l'objet réel pour \"inverser la dépendance\" de la classe EmailAdressValidator non plus sur la classe \"DomainValidator\" mais sur une interface \"IDomainValidator\""}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple avec injection par constructeur :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// Interface IDomainValidator\npublic interface IDomainValidator\n{\nbool Exists(string sDomain);\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// Classe à tester\nclass  EmailAddressValidator\n{\n// Interface\nprivate readonly IDomainValidator domainValidator;"}]},{"type":"element","tag":"code","props":{"code":"public EmailAddressValidator(IDomainValidator domainValidator)\n{\n    this.domainValidator = domainValidator;\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(sEmailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}\n...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public EmailAddressValidator(IDomainValidator domainValidator)\n{\n    this.domainValidator = domainValidator;\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(sEmailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}\n...\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple avec injection par mutatteur (propriété getter/setter) :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// Classe à tester\nclass  EmailAddressValidator\n{\n// Interface\npublic IDomainValidator domainValidator { get; set; }"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public EmailAddressValidator()\n{\n}\n...."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A partir de là, il faut écrire une implémentation de IDomainValidator valable uniquement pour le test."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"class FakeDomainValidator : IDomainValidator\n{\npublic bool Exists(string sDomain)\n{\nreturn true;\n}\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Les tests de EmailAddressValidator pourront donc être indépendants de l'implémentation de IDomainValidator."}]}]},{"type":"element","tag":"h3","props":{"id":"limitations"},"children":[{"type":"text","value":"Limitations"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Si vous souhaitez tester le comportement de EmailAddressValidator dans le cas d'un retour true et false, il faut écrire deux bouchons."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nSi l'objet est complexe et contient plus de 3 méthodes, l'écriture des bouchons est rapidement fastidieuse."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pour cela, il faut utiliser des outils qui génèrent les bouchons dynamiquement. Voir partie suivante sur les mocks."}]},{"type":"element","tag":"h1","props":{"id":"présentation-des-mocks"},"children":[{"type":"text","value":"Présentation des Mocks"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Les Mocks permettent de s'affranchir de l'écriture des bouchons cités plus haut. Deux lignes de code suffisent pour créer une implémentation vide d'une interface :"}]},{"type":"element","tag":"code","props":{"code":"  var mock = new Mock();\n  IDomainValidator domainValidatorMock = mock.Object;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  var mock = new Mock();\n  IDomainValidator domainValidatorMock = mock.Object;\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"mocks-pour-tester-létat-des-objets"},"children":[{"type":"text","value":"Mocks pour tester l'état des objets"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On peut désormais écrire :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"EAV = new EmailAddressValidator ();\nEAV.domainValidator = domainValidatorMock;\nEAV.CheckDomainExists(\"domaine.fr\");"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Par défaut, nous n'avons pas défini ce que devait renvoyer Exists de domainValidatorMock, donc la méthode va renvoyer false (la valeur d'un bool par défaut)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Ici, on va donc tester la méthode CheckDomainExists de EmailAddressValidator sans faire d'appel à un web service."}]}]},{"type":"element","tag":"h2","props":{"id":"préciser-le-comportement-du-mock"},"children":[{"type":"text","value":"Préciser le comportement du mock"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans l'exemple précédent, on va coder deux tests, un ou le résultat du IDomainValidator est false, l'autre ou c'est true. Pour cela, on va initialiser le mock avec la méthode Setup :"}]},{"type":"element","tag":"code","props":{"code":"    \\[Test\\]\n    public void TestDomainExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(true);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n\n    \\[Test\\]\n    public void TestDomainNotExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \\[Test\\]\n    public void TestDomainExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(true);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n\n    \\[Test\\]\n    public void TestDomainNotExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La méthode Setup prend une lambda expression indiquant le comportement attendu de la méthode Exists sur l'objet."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On remarque l'utilisation de It.IsAny"},{"type":"element","tag":"string","props":{},"children":[{"type":"text","value":"() qui indique que l'appel de Exists avec n'importe quel string renverra true."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tout le comportement de la méthode bouchonnée peut être précisé comme cela."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nPar exemple si la méthode doit renvoyer une exception :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false).Throws(new ArgumentException(\"invalid argument\"));"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On peut indiquer que l'appel de la méthode doit ensuite déclencher une fonction de rappel :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false).Callback(() => MethodToCall());"}]},{"type":"element","tag":"h2","props":{"id":"mock-pour-tester-le-comportement-des-objets"},"children":[{"type":"text","value":"Mock pour tester le comportement des objets"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En réalité il existe deux types de tests à faire :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"tester que EmailAdressValidator se comporte bien"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"tester que DomainValidator est correctement appelé par EmailAdressValidator"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pour le deuxième type de test, le mock peut ajouter des attentes (ou "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"expectations"}]},{"type":"text","value":") :"}]},{"type":"element","tag":"code","props":{"code":"        // \"Behavior verification\" (vérifications du comportement de l'objet par des attentes)\n        mock.Verify(foo => foo.Exists(It.IsAny())).Returns(false), Times.AtMostOnce(),\n        \"Fail message: method IDomainValidator.Existsshould be called and called only once\");\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        // \"Behavior verification\" (vérifications du comportement de l'objet par des attentes)\n        mock.Verify(foo => foo.Exists(It.IsAny())).Returns(false), Times.AtMostOnce(),\n        \"Fail message: method IDomainValidator.Existsshould be called and called only once\");\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ici par exemple on vérifie que la méthode Exists ne peut être appelé qu'une seule fois."}]}]},"id":"144","date":"2010-11-28","categories":["waza"],"tags":["csharp","testunitaire"],"img":"","cover":"cover5.jpg","readingTime":{"text":"8 min read","minutes":7.05,"time":423000,"words":1410},"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Par définition (Cf. "},{"type":"element","tag":"a","props":{"href":"http://fr.wikipedia.org/wiki/Test_unitaire","rel":["nofollow"]},"children":[{"type":"text","value":"Wikipédia"}]},{"type":"text","value":" ) un test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme (appelée « unité » ou « module »)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test est dit "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"unitaire"}]},{"type":"text","value":" s'il ne fait pas appel à d'autres ressources que la classe testé. Un test unitaire n'utilise donc pas de base de données, de socket, MQ series etc... à l'inverse d'un test d'intégration."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test d'"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"intégration"}]},{"type":"text","value":" est donc par extension un test qui peut utiliser des ressources externes : bases de données par exemple."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Voyons ce que ça donne en C#."}]},{"type":"element","tag":"h2","props":{"id":"écriture-dun-premier-test"},"children":[{"type":"text","value":"Écriture d'un premier test"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Par convention, une classe de test correspond généralement aux tests d'une classe de votre code."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Exemple"}]},{"type":"text","value":" :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"votre classe : "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"EmailAdressValidator"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class  EmailAddressValidator\n{\nprivate DomainValidator domainValidator;"}]},{"type":"element","tag":"code","props":{"code":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n        return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n    ...\npublic bool CheckDomainExists(string domain)\n{\n        return  domainValidator.Exists(domain);\n}\n...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n        return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n    ...\npublic bool CheckDomainExists(string domain)\n{\n        return  domainValidator.Exists(domain);\n}\n...\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"la classe de test : "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"EmailAdressValidatorTest"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Une classe de test comporte un stéréotype TestFixture, les méthodes de test ont un stéréotype Test."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[TestFixture]\npublic class EmailValidatorTest\n{\nEmailAddressValidator EAV;"}]},{"type":"element","tag":"code","props":{"code":"\\[SetUp\\]\npublic void SetUp()\n{\n    EAV = new EmailAddressValidator ();\n}\n\n\\[TearDown\\]\npublic void TearDown()\n{\n    EVA.Clean();\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[SetUp\\]\npublic void SetUp()\n{\n    EAV = new EmailAddressValidator ();\n}\n\n\\[TearDown\\]\npublic void TearDown()\n{\n    EVA.Clean();\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"[Test]\npublic void TestEmailSyntaxArobas()\n{\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\""},{"type":"element","tag":"a","props":{"href":"mailto:Nom@entreprise.com"},"children":[{"type":"text","value":"Nom@entreprise.com"}]},{"type":"text","value":"\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n}\n}"}]},{"type":"element","tag":"h2","props":{"id":"différentes-assertions"},"children":[{"type":"text","value":"Différentes assertions"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans un test, on cherche toujours à vérifier un comportement. On utilise donc des assertions, ces assertions définissent le comportement attendu."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En francais, une assertion est un énoncé considéré comme vrai."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pour un test unitaire, il s'agit d'une expression qui doit être vrai pour que le test réussisse."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"NUnit et MBunit utilise une classe statique "},{"type":"element","tag":"a","props":{"href":"http://gallio.org/api/html/AllMembers_T_MbUnit_Framework_Assert.htm","rel":["nofollow"]},"children":[{"type":"text","value":"Assert"}]},{"type":"text","value":" pour les assertions :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cette classe "},{"type":"element","tag":"a","props":{"href":"http://gallio.org/api/html/AllMembers_T_MbUnit_Framework_Assert.htm","rel":["nofollow"]},"children":[{"type":"text","value":"Assert"}]},{"type":"text","value":" va nous permettre de tester entre autre :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"l'égalité : Assert.Equals"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"le non null : Assert.IsNotNull"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"une condition Assert.IsTrue"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nmais aussi, la présence dans une plage de valeur, une égalité approximative, l'égalité des références etc..."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test comporte toujours des assertions."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// CheckEmailAdressSyntax doit renvoyer true avec le paramètre \""},{"type":"element","tag":"a","props":{"href":"mailto:Nom@entreprise.com"},"children":[{"type":"text","value":"Nom@entreprise.com"}]},{"type":"text","value":"\"\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\""},{"type":"element","tag":"a","props":{"href":"mailto:Nom@entreprise.com"},"children":[{"type":"text","value":"Nom@entreprise.com"}]},{"type":"text","value":"\"));"}]},{"type":"element","tag":"h2","props":{"id":"setupteardown"},"children":[{"type":"text","value":"Setup/TearDown"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Il est parfois nécessaire d'effectuer des opérations avant et après chaque test. Une classe peut donc définir des méthodes appelées avant et après chaque test avec les stéréotypes Setup et Teardown."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// toujours exécuté avant les tests\n[SetUp]\npublic void SetUp()\n{\nEAV = new EmailAddressValidator ();\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// toujours exécuté après les tests\n[TearDown]\npublic void TearDown()\n{\nEVA.Clean();\n}"}]},{"type":"element","tag":"h2","props":{"id":"la-couverture-de-code"},"children":[{"type":"text","value":"La couverture de code"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"couverture de code"}]},{"type":"text","value":" est une métrique utilisée en génie logiciel pour décrire le taux de code source "},{"type":"element","tag":"a","props":{"href":"http://fr.wikipedia.org/wiki/Code_source","rel":["nofollow"]},"children":[{"type":"text","value":"http://fr.wikipedia.org/wiki/Code_source"}]},{"type":"text","value":" testé d'un programme. Ceci permet de mesurer la qualité des tests effectués."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En .NET on utilise "},{"type":"element","tag":"a","props":{"href":"http://www.ncover.com/","rel":["nofollow"]},"children":[{"type":"text","value":"NCover"}]},{"type":"text","value":" pour mesurer cette couverture de code. "},{"type":"element","tag":"a","props":{"href":"http://www.ncover.com/","rel":["nofollow"]},"children":[{"type":"text","value":"NCover"}]},{"type":"text","value":" va calculer à partir des tests joués et du code initial l'ensemble des chemins qui ont été parcourus et fournir un pourcentage du code parcouru par rapport au code non parcouru."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ci-dessous, un exemple des rapports proposés par NCover :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"XXXX"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans les tests précédents, NCover remarque que l'on ne passe pas par "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"CheckDomainExists"}]},{"type":"text","value":" que l'on verra plus bas sur cette page. De plus le test sur la nullité de la chaine entrée n'est jamais évalué à true :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"if(emailAddress == null )\n{\nthrow new NullReferenceException();\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un test avec une chaine null ferait remonter la couverture de code."}]},{"type":"element","tag":"h2","props":{"id":"test-paramétré"},"children":[{"type":"text","value":"Test paramétré"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans le test précédent, on réécrit x fois la même ligne pour tester avec des paramètres différents :"}]},{"type":"element","tag":"code","props":{"code":"  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Premier défaut à cette méthode :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"il est conseillé d'avoir une assertion par méthode de test, ca permet d'être sur que tout les cas de test sont joués (sinon la première erreur empêche l'execution des autres tests)."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"code","props":{"code":"\\[Test\\]\npublic void TestInvalidEmailSyntaxWithTwoArobas()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n}\n\n\\[Test\\]\npublic void TestInvalidEmailSyntaxWithoutName()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[Test\\]\npublic void TestInvalidEmailSyntaxWithTwoArobas()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n}\n\n\\[Test\\]\npublic void TestInvalidEmailSyntaxWithoutName()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Second défaut, on duplique le code testé. Cela aurait été plus gênant avec un code sur plusieurs lignes."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Solution :"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nPour éviter de réécrire x fois le même test avec des paramètres différents, on va utiliser des tests paramétrés :"}]},{"type":"element","tag":"code","props":{"code":"\\[Test\\]\n\\[Row(\"Nom@@entreprise.com\")\\]\n\\[Row(\"Nomentreprise.com\")\\]\n\\[Row(\"@entreprise.com\")\\]\n\\[Row(\"Nom@\")\\]\npublic void TestEmailSyntaxArobas(string name)\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (name));\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[Test\\]\n\\[Row(\"Nom@@entreprise.com\")\\]\n\\[Row(\"Nomentreprise.com\")\\]\n\\[Row(\"@entreprise.com\")\\]\n\\[Row(\"Nom@\")\\]\npublic void TestEmailSyntaxArobas(string name)\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (name));\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Le même test est joué 4 fois pour chaque valeur de paramètre. L'attribut Row est utilisé pour chaque paramétre et celui-ci est passé en paramètre de la méthode."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Autre exemple avec un code plus complexe :"}]},{"type":"element","tag":"code","props":{"code":"\\[Test\\]\n\\[Row(\"Milou\")\\]\n\\[Row(\"Idefix\")\\]\npublic void TestWithFakeAndRowTest(string name)\n{\n    // \"Setup\" (initialisation des objets pour le test)\n    OrderWriter orderWriter = new OrderWriter(new FakeWriter());\n    Order order = new Order() { OrderId = 7001, Pet = new Dog(name) };\n\n    // \"Execute\" (Exécution du test : écriture de l'ordre sur le système)\n    orderWriter.WriteOrder(order);\n\n    // \"State verification\" (vérification de l'état de l'objet par des assertions)\n    Assert.AreEqual(name, order.Pet.Name);\n    Assert.IsTrue(order.IsFilled);\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\\[Test\\]\n\\[Row(\"Milou\")\\]\n\\[Row(\"Idefix\")\\]\npublic void TestWithFakeAndRowTest(string name)\n{\n    // \"Setup\" (initialisation des objets pour le test)\n    OrderWriter orderWriter = new OrderWriter(new FakeWriter());\n    Order order = new Order() { OrderId = 7001, Pet = new Dog(name) };\n\n    // \"Execute\" (Exécution du test : écriture de l'ordre sur le système)\n    orderWriter.WriteOrder(order);\n\n    // \"State verification\" (vérification de l'état de l'objet par des assertions)\n    Assert.AreEqual(name, order.Pet.Name);\n    Assert.IsTrue(order.IsFilled);\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"le-bouchonnage"},"children":[{"type":"text","value":"Le bouchonnage"}]},{"type":"element","tag":"h3","props":{"id":"problématique"},"children":[{"type":"text","value":"Problématique"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Comme dit plus haut, un test unitaire doit être indépendant des ressources externes : base de données, file de message etc..."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Mais il arrive souvent que l'on utilise ces ressources dans les classes testées."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public class  EmailAddressValidator\n{\nDomainValidator domainValidator;"}]},{"type":"element","tag":"code","props":{"code":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}...\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ici le DomainValidator fait appel à un service web pour vérifier l'existence d'un nom de domaine. Le test unitaire de la méthode CheckDomainExists pose donc problème."}]},{"type":"element","tag":"h3","props":{"id":"solution"},"children":[{"type":"text","value":"Solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La solution consiste à utiliser un bouchon à la place du DomainValidator."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pour cela, un peu de remaniement de code est nécessaire ("},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"refactoring"}]},{"type":"text","value":") :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"l'objet DomainValidator n'est plus instancié dans le constructeur mais injecté par constructeur ou par mutateur (propriété)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"On utilise une interface à la place de l'objet réel pour \"inverser la dépendance\" de la classe EmailAdressValidator non plus sur la classe \"DomainValidator\" mais sur une interface \"IDomainValidator\""}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple avec injection par constructeur :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// Interface IDomainValidator\npublic interface IDomainValidator\n{\nbool Exists(string sDomain);\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// Classe à tester\nclass  EmailAddressValidator\n{\n// Interface\nprivate readonly IDomainValidator domainValidator;"}]},{"type":"element","tag":"code","props":{"code":"public EmailAddressValidator(IDomainValidator domainValidator)\n{\n    this.domainValidator = domainValidator;\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(sEmailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}\n...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"public EmailAddressValidator(IDomainValidator domainValidator)\n{\n    this.domainValidator = domainValidator;\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(sEmailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}\n...\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Exemple avec injection par mutatteur (propriété getter/setter) :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"// Classe à tester\nclass  EmailAddressValidator\n{\n// Interface\npublic IDomainValidator domainValidator { get; set; }"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"public EmailAddressValidator()\n{\n}\n...."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A partir de là, il faut écrire une implémentation de IDomainValidator valable uniquement pour le test."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"class FakeDomainValidator : IDomainValidator\n{\npublic bool Exists(string sDomain)\n{\nreturn true;\n}\n}"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Les tests de EmailAddressValidator pourront donc être indépendants de l'implémentation de IDomainValidator."}]}]},{"type":"element","tag":"h3","props":{"id":"limitations"},"children":[{"type":"text","value":"Limitations"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Si vous souhaitez tester le comportement de EmailAddressValidator dans le cas d'un retour true et false, il faut écrire deux bouchons."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nSi l'objet est complexe et contient plus de 3 méthodes, l'écriture des bouchons est rapidement fastidieuse."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pour cela, il faut utiliser des outils qui génèrent les bouchons dynamiquement. Voir partie suivante sur les mocks."}]},{"type":"element","tag":"h1","props":{"id":"présentation-des-mocks"},"children":[{"type":"text","value":"Présentation des Mocks"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Les Mocks permettent de s'affranchir de l'écriture des bouchons cités plus haut. Deux lignes de code suffisent pour créer une implémentation vide d'une interface :"}]},{"type":"element","tag":"code","props":{"code":"  var mock = new Mock();\n  IDomainValidator domainValidatorMock = mock.Object;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  var mock = new Mock();\n  IDomainValidator domainValidatorMock = mock.Object;\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"mocks-pour-tester-létat-des-objets"},"children":[{"type":"text","value":"Mocks pour tester l'état des objets"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On peut désormais écrire :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"EAV = new EmailAddressValidator ();\nEAV.domainValidator = domainValidatorMock;\nEAV.CheckDomainExists(\"domaine.fr\");"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Par défaut, nous n'avons pas défini ce que devait renvoyer Exists de domainValidatorMock, donc la méthode va renvoyer false (la valeur d'un bool par défaut)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Ici, on va donc tester la méthode CheckDomainExists de EmailAddressValidator sans faire d'appel à un web service."}]}]},{"type":"element","tag":"h2","props":{"id":"préciser-le-comportement-du-mock"},"children":[{"type":"text","value":"Préciser le comportement du mock"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dans l'exemple précédent, on va coder deux tests, un ou le résultat du IDomainValidator est false, l'autre ou c'est true. Pour cela, on va initialiser le mock avec la méthode Setup :"}]},{"type":"element","tag":"code","props":{"code":"    \\[Test\\]\n    public void TestDomainExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(true);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n\n    \\[Test\\]\n    public void TestDomainNotExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    \\[Test\\]\n    public void TestDomainExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(true);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n\n    \\[Test\\]\n    public void TestDomainNotExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La méthode Setup prend une lambda expression indiquant le comportement attendu de la méthode Exists sur l'objet."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On remarque l'utilisation de It.IsAny"},{"type":"element","tag":"string","props":{},"children":[{"type":"text","value":"() qui indique que l'appel de Exists avec n'importe quel string renverra true."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tout le comportement de la méthode bouchonnée peut être précisé comme cela."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nPar exemple si la méthode doit renvoyer une exception :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false).Throws(new ArgumentException(\"invalid argument\"));"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On peut indiquer que l'appel de la méthode doit ensuite déclencher une fonction de rappel :"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"mock.Setup(foo => foo.Exists(It.IsAny())).Returns(false).Callback(() => MethodToCall());"}]},{"type":"element","tag":"h2","props":{"id":"mock-pour-tester-le-comportement-des-objets"},"children":[{"type":"text","value":"Mock pour tester le comportement des objets"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En réalité il existe deux types de tests à faire :"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"tester que EmailAdressValidator se comporte bien"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"tester que DomainValidator est correctement appelé par EmailAdressValidator"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"pour le deuxième type de test, le mock peut ajouter des attentes (ou "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"expectations"}]},{"type":"text","value":") :"}]},{"type":"element","tag":"code","props":{"code":"        // \"Behavior verification\" (vérifications du comportement de l'objet par des attentes)\n        mock.Verify(foo => foo.Exists(It.IsAny())).Returns(false), Times.AtMostOnce(),\n        \"Fail message: method IDomainValidator.Existsshould be called and called only once\");\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        // \"Behavior verification\" (vérifications du comportement de l'objet par des attentes)\n        mock.Verify(foo => foo.Exists(It.IsAny())).Returns(false), Times.AtMostOnce(),\n        \"Fail message: method IDomainValidator.Existsshould be called and called only once\");\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ici par exemple on vérifie que la méthode Exists ne peut être appelé qu'une seule fois."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"écriture-dun-premier-test","depth":2,"text":"Écriture d'un premier test"},{"id":"différentes-assertions","depth":2,"text":"Différentes assertions"},{"id":"setupteardown","depth":2,"text":"Setup/TearDown"},{"id":"la-couverture-de-code","depth":2,"text":"La couverture de code"},{"id":"test-paramétré","depth":2,"text":"Test paramétré"},{"id":"le-bouchonnage","depth":2,"text":"Le bouchonnage","children":[{"id":"problématique","depth":3,"text":"Problématique"},{"id":"solution","depth":3,"text":"Solution"},{"id":"limitations","depth":3,"text":"Limitations"}]},{"id":"mocks-pour-tester-létat-des-objets","depth":2,"text":"Mocks pour tester l'état des objets"},{"id":"préciser-le-comportement-du-mock","depth":2,"text":"Préciser le comportement du mock"},{"id":"mock-pour-tester-le-comportement-des-objets","depth":2,"text":"Mock pour tester le comportement des objets"}]}},"_type":"markdown","_id":"content:articles:2010:11:28:introduction-aux-tests-unitaires-et-aux-bouchons-en-c-2.md","_source":"content","_file":"articles/2010/11/28/introduction-aux-tests-unitaires-et-aux-bouchons-en-c-2.md","_extension":"md"}