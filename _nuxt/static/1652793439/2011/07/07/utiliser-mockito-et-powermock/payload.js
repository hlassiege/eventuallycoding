__NUXT_JSONP__("/2011/07/07/utiliser-mockito-et-powermock", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K){return {data:[{article:{slug:"utiliser-mockito-et-powermock",description:"[![](\u002Fimages\u002Fmockito.jpg \"mockito\")](http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2011\u002F07\u002Fmockito.jpg)Vous connaissez peut-être déjà [Mockito](http:...",title:"Utiliser Mockito et PowerMock",date:"2011-07-07",categories:["waza"],tags:["java",s,"powermock","testunitaire"],img:"mockito.jpg",cover:"cover2.jpg",toc:[{id:t,depth:g,text:u},{id:v,depth:g,text:w},{id:x,depth:g,text:y},{id:z,depth:g,text:A},{id:B,depth:g,text:C},{id:D,depth:g,text:E},{id:F,depth:g,text:G}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{href:"http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2011\u002F07\u002Fmockito.jpg",rel:[n,o,p],target:q},children:[{type:b,tag:"img",props:{alt:"",src:"\u002Fimages\u002Fmockito.jpg",title:s},children:[]}]},{type:a,value:"Vous connaissez peut-être déjà "},{type:b,tag:e,props:{href:H,rel:[n,o,p],target:q},children:[{type:a,value:"Mockito"}]},{type:a,value:" ? En fait vous connaissez même surement pour ceux qui ont eu la chance d'être présent à la "},{type:b,tag:e,props:{href:"http:\u002F\u002Fjduchess.org\u002Fduchess-france\u002Fblog\u002Fmarmite-soiree-crumble-pour-la-premiere-edition\u002F",rel:[n,o,p],target:q},children:[{type:a,value:"première soirée Marmite des JDuchess"}]},{type:a,value:I}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et pourquoi j'en parle ? Bon, pas seulement parce que leur logo est un mojito géant et que j'adore cette boisson (*), mais tout simplement pour présenter quelques astuces d'utilisation avec PowerMock."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"* inconsciemment ca doit jouer un peu quand même"}]},{type:a,value:c},{type:b,tag:h,props:{id:t},children:[{type:b,tag:e,props:{href:"#mais-cest-quoi-mockito-",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Petit retour aux sources, selon "},{type:b,tag:e,props:{href:H,rel:[n,o,p],target:q},children:[{type:a,value:"le site officiel"}]},{type:a,value:" : \"Mockito is a mocking framework that tastes really good.\""}]},{type:a,value:c},{type:b,tag:h,props:{id:v},children:[{type:b,tag:e,props:{href:"#et-pourquoi-mockito-",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Parce que son API utilise un DSL agréable à utiliser, lisible, typé :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"when(mockedList.get(0)).thenReturn(\"first\");\nwhen(mockedList.get(2)).thenThrow(new ArrayOutOfBoundException());"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pas de record-replay obligatoire"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ca c'est pour ceux qui connaissent EasyMock, pas besoin de préciser le comportement attendu de votre mock dans ses moindres détails. On se focalise juste sur le resultat produit par l'objet testé, pas sur sa facon d'utiliser le mock. (A noter que EasyMock permet désormais de créer des mocks sans nécessité de préciser son comportement avec createNiceMock)"}]},{type:a,value:c},{type:b,tag:h,props:{id:x},children:[{type:b,tag:e,props:{href:"#et-pourquoi-powermock-",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Parce que Mockito tout seul ne permet pas de gérer quelques cas sur du code \"intestable\". Et ce que j'appelle intestable, alors ça, je suis sur que vous en avez déjà vu (ou alors vous avez une veine incroyable et je veux savoir où vous travaillez !) :"}]},{type:a,value:c},{type:b,tag:"ul",props:{},children:[{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:"des méthodes statiques de partout (getInstance, Lookup, etc...)"}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:"des blocs statiques"}]},{type:a,value:c},{type:b,tag:r,props:{},children:[{type:a,value:"un constructeur qui fait papa-maman (j'adore cette expression...)"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour info, vous avez déjà un bon article sur le sujet mais concernant JMockit : "},{type:b,tag:e,props:{href:J,rel:[n,o,p],target:q},children:[{type:a,value:J}]}]},{type:a,value:c},{type:b,tag:h,props:{id:z},children:[{type:b,tag:e,props:{href:"#mais-revenons-aux-fondamentaux-pourquoi-utiliser-des-mocks-",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Tout simplement parce que quand on parle de test unitaire, on fait référence à des tests "},{type:b,tag:f,props:{},children:[{type:a,value:"UNITAIRES"}]},{type:a,value:" ! Et tester unitairement un objet ça veut dire le tester en isolation, donc pas d'appel à une base de données, à une file de messages etc... Dans l'idéal, un test unitaire ne teste qu'une seule classe. On utilise d'ailleurs une convention simple et assez parlante pour cela : MonObjet est testé par MonObjetTest (ou TestMonObjet)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:"em",props:{},children:[{type:a,value:"Point personnel, sur ce dernier point, je suis plus coulant. Un test reste unitaire du moment que je n'utilise pas de ressources externes (base de données etc...) mais j'accepte l'utilisation d'autre classes du moment que je maitrise leurs propres interactions."}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et donc pour tester en isolation nous allons avoir besoin des fausses implémentations de toutes les dépendances de notre objet. Nous pourrions les écrire toutes, en admettant que chaque dépendance soit utilisé via une interface mais ce serait très fastidieux. Utiliser une librairie de mock permettra donc d'éviter une tâche bien pénible."}]},{type:a,value:c},{type:b,tag:h,props:{id:B},children:[{type:b,tag:e,props:{href:"#passons-%C3%A0-la-pratique",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:C}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Mockito est fourni avec runner Junit que l'on peut activer comme suit :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@RunWith(MockitoJUnitRunner.class)\npublic class TestMyObjet\n{\n@InjectMocks\nprivate MyObject myObjet = new MyObject();"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@Mock\nprivate MyComplexObject myComplexObject;"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@Mock\nprivate IMyComplexInterface anotherComplexObject ;\n...\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Première bonne nouvelle, en utilisant l'annotation "},{type:b,tag:f,props:{},children:[{type:a,value:"@Mock"}]},{type:a,value:", le runner Mockito va créer pour vous tout les mocks qui sont déclarés que ce soit des interfaces ou des classes."}]},{type:a,value:c},{type:b,tag:h,props:{id:D},children:[{type:b,tag:e,props:{href:"#g%C3%A9rer-les-attributs-priv%C3%A9s-sans-setters-",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:E}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Là ou le runner est encore plus fort, c'est qu'il va injecter tout les mocks nécessaires sur l'objet annoté par "},{type:b,tag:f,props:{},children:[{type:a,value:"@InjectMocks"}]},{type:a,value:". Et là c'est très pratique, surtout si vous avez du code sans setter."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public class MyObjet\n{\n...\n@Autowired\nprivate MyComplexObjet myComplexObjet;\n..."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"myComplexObjet est privé et n'a aucun setter, donc sans le runner Mockito vous ne pourriez pas l'injecter."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Bon en fait, si comme nous allons le voir."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"D'ailleurs dans le cas suivant Mockito ne vous sera d'aucune aide et du coup nous allons quand même avoir recours à des ruses de sioux :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public class MyObjet\n{\n@Value(\"${onekey}\")\nprivate String onekey;\n@Value(\"${anotherkey}\")\nprivate String anotherkey;\n...\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans ce cas, vous pouvez utiliser Spring à la rescousse et "},{type:b,tag:f,props:{},children:[{type:a,value:"ReflectionTestUtils"}]},{type:a,value:" :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@Before\npublic void initialize ()\n{\nReflectionTestUtils.setField(myObject, \"onekey\", \"one\");\nReflectionTestUtils.setField(myObject, \"anotherkey\", \"two\");\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"C'est pas du Mockito mais ça valait le coup d'être cité."}]},{type:a,value:c},{type:b,tag:h,props:{id:F},children:[{type:b,tag:e,props:{href:"#mocker-une-m%C3%A9thode-statique",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:G}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En fait Mockito n'est pas capable de mocker une méthode statique par lui même. Pour cela il va falloir appeler "},{type:b,tag:e,props:{href:"http:\u002F\u002Fcode.google.com\u002Fp\u002Fpowermock\u002F",rel:[n,o,p],target:q},children:[{type:a,value:"PowerMock"}]},{type:a,value:" à la rescousse."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour l'activer, vous allez désormais utiliser un autre runner : "},{type:b,tag:f,props:{},children:[{type:a,value:"PowerMockRunner"}]},{type:a,value:I}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@RunWith(PowerMockRunner.class)\n@PrepareForTest({ Lookup.class })\n@PowerMockIgnore(\"org.apache.commons.logging.*\")\npublic class TestMyObject\n{\n...\n@Before\npublic void initialize() throws Exception\n{\n\u002F\u002F Comme vous n'utilisez pas MockitoRunner, vous devez faire appel à initMocks pour initialiser vos mocks\nMockitoAnnotations.initMocks(this);\n...\n\u002F\u002F o utilise PowerMockito pour mocker l'appel statique à Lookup.getInstance()\n\u002F\u002F -------------------------------------------------------------------\nPowerMockito.mockStatic(Lookup.class);\nLookup lookup = mock(Lookup.class);\nwhen(Lookup.getInstance()).thenReturn(lookup);\n...\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Explications de texte :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Activation du runner :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@RunWith(PowerMockRunner.class)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Liste des objets dont on va faire un mock de méthode statiques :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@PrepareForTest({ Lookup.class })"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La ligne suivante est nécessaire car on n'utilise plus le runner "},{type:b,tag:f,props:{},children:[{type:a,value:"MockitoJUnitRunner"}]},{type:a,value:" mais que l'on souhaite quand même utiliser les annotations "},{type:b,tag:f,props:{},children:[{type:a,value:"Mocks"}]},{type:a,value:" et "},{type:b,tag:f,props:{},children:[{type:a,value:"InjectMocks"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"MockitoAnnotations.initMocks(this);"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"et enfin, le mock de la méthode statique :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"PowerMockito.mockStatic(Lookup.class);\nLookup lookup = mock(Lookup.class);\nwhen(Lookup.getInstance()).thenReturn(lookup );"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Facile non ?"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Allez, une petite dernière pour la route. Et si mon objet doit implémenter deux interfaces ? Par exemple j'utilise Carbon pour l'injection de dépendance (ok on sent le projet legacy là) et du coup tout mes beans doivent aussi implémenter l'interface Component."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ouf, Mockito le gère depuis 2009 :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"mock(Lookup.class, withSettings().extraInterfaces(Component.class));"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Voila, vous en savez (peut-être) un peu plus sur Mockito, à vous de jouer maintenant !"}]}]},dir:"\u002Farticles\u002F2011\u002F07\u002F07",path:"\u002Farticles\u002F2011\u002F07\u002F07\u002Futiliser-mockito-et-powermock",extension:".md",createdAt:K,updatedAt:K,bodyPlainText:"\nVous connaissez peut-être déjà Mockito ? En fait vous connaissez même surement pour ceux qui ont eu la chance d'être présent à la première soirée Marmite des JDuchess.\n\nEt pourquoi j'en parle ? Bon, pas seulement parce que leur logo est un mojito géant et que j'adore cette boisson (\\*), mais tout simplement pour présenter quelques astuces d'utilisation avec PowerMock.\n\n\\* inconsciemment ca doit jouer un peu quand même\n\nMais c'est quoi Mockito ?\n\nPetit retour aux sources, selon le site officiel : \"Mockito is a mocking framework that tastes really good.\"\n\nEt pourquoi Mockito ?\n\nParce que son API utilise un DSL agréable à utiliser, lisible, typé :\n\n    when(mockedList.get(0)).thenReturn(\"first\");\n    when(mockedList.get(2)).thenThrow(new ArrayOutOfBoundException());\n\nPas de record-replay obligatoire\n\nCa c'est pour ceux qui connaissent EasyMock, pas besoin de préciser le comportement attendu de votre mock dans ses moindres détails. On se focalise juste sur le resultat produit par l'objet testé, pas sur sa facon d'utiliser le mock. (A noter que EasyMock permet désormais de créer des mocks sans nécessité de préciser son comportement avec createNiceMock)\n\nEt pourquoi Powermock ?\n\nParce que Mockito tout seul ne permet pas de gérer quelques cas sur du code \"intestable\". Et ce que j'appelle intestable, alors ça, je suis sur que vous en avez déjà vu (ou alors vous avez une veine incroyable et je veux savoir où vous travaillez !) :\n\ndes méthodes statiques de partout (getInstance, Lookup, etc...)\ndes blocs statiques\nun constructeur qui fait papa-maman (j'adore cette expression...)\n\nPour info, vous avez déjà un bon article sur le sujet mais concernant JMockit : http:\u002F\u002Ffchabanois.developpez.com\u002Ftutorial\u002Fjava\u002Fjmockit\u002F\n\nMais revenons aux fondamentaux, pourquoi utiliser des mocks ?\n\nTout simplement parce que quand on parle de test unitaire, on fait référence à des tests UNITAIRES ! Et tester unitairement un objet ça veut dire le tester en isolation, donc pas d'appel à une base de données, à une file de messages etc... Dans l'idéal, un test unitaire ne teste qu'une seule classe. On utilise d'ailleurs une convention simple et assez parlante pour cela : MonObjet est testé par MonObjetTest (ou TestMonObjet).\n\nPoint personnel, sur ce dernier point, je suis plus coulant. Un test reste unitaire du moment que je n'utilise pas de ressources externes (base de données etc...) mais j'accepte l'utilisation d'autre classes du moment que je maitrise leurs propres interactions.\n\nEt donc pour tester en isolation nous allons avoir besoin des fausses implémentations de toutes les dépendances de notre objet. Nous pourrions les écrire toutes, en admettant que chaque dépendance soit utilisé via une interface mais ce serait très fastidieux. Utiliser une librairie de mock permettra donc d'éviter une tâche bien pénible.\n\nPassons à la pratique\n\nMockito est fourni avec runner Junit que l'on peut activer comme suit :\n\n@RunWith(MockitoJUnitRunner.class)\npublic class TestMyObjet\n{\n@InjectMocks\nprivate MyObject myObjet = new MyObject();\n\n@Mock\nprivate MyComplexObject myComplexObject;\n\n@Mock\nprivate IMyComplexInterface anotherComplexObject ;\n...\n}\n\nPremière bonne nouvelle, en utilisant l'annotation @Mock, le runner Mockito va créer pour vous tout les mocks qui sont déclarés que ce soit des interfaces ou des classes.\n\nGérer les attributs privés sans setters !\n\nLà ou le runner est encore plus fort, c'est qu'il va injecter tout les mocks nécessaires sur l'objet annoté par @InjectMocks. Et là c'est très pratique, surtout si vous avez du code sans setter.\n\npublic class MyObjet\n{\n...\n@Autowired\nprivate MyComplexObjet myComplexObjet;\n...\n\nmyComplexObjet est privé et n'a aucun setter, donc sans le runner Mockito vous ne pourriez pas l'injecter.\n\nBon en fait, si comme nous allons le voir.\n\nD'ailleurs dans le cas suivant Mockito ne vous sera d'aucune aide et du coup nous allons quand même avoir recours à des ruses de sioux :\n\npublic class MyObjet\n{\n@Value(\"${onekey}\")\nprivate String onekey;\n@Value(\"${anotherkey}\")\nprivate String anotherkey;\n...\n}\n\nDans ce cas, vous pouvez utiliser Spring à la rescousse et ReflectionTestUtils :\n\n@Before\npublic void initialize ()\n{\nReflectionTestUtils.setField(myObject, \"onekey\", \"one\");\nReflectionTestUtils.setField(myObject, \"anotherkey\", \"two\");\n}\n\nC'est pas du Mockito mais ça valait le coup d'être cité.\n\nMocker une méthode statique\n\nEn fait Mockito n'est pas capable de mocker une méthode statique par lui même. Pour cela il va falloir appeler PowerMock à la rescousse.\n\nPour l'activer, vous allez désormais utiliser un autre runner : PowerMockRunner.\n\n@RunWith(PowerMockRunner.class)\n@PrepareForTest({ Lookup.class })\n@PowerMockIgnore(\"org.apache.commons.logging.\\*\")\npublic class TestMyObject\n{\n...\n@Before\npublic void initialize() throws Exception\n{\n\u002F\u002F Comme vous n'utilisez pas MockitoRunner, vous devez faire appel à initMocks pour initialiser vos mocks\nMockitoAnnotations.initMocks(this);\n...\n\u002F\u002F o utilise PowerMockito pour mocker l'appel statique à Lookup.getInstance()\n\u002F\u002F -------------------------------------------------------------------\nPowerMockito.mockStatic(Lookup.class);\nLookup lookup = mock(Lookup.class);\nwhen(Lookup.getInstance()).thenReturn(lookup);\n...\n}\n\nExplications de texte :\n\nActivation du runner :\n\n@RunWith(PowerMockRunner.class)\n\nListe des objets dont on va faire un mock de méthode statiques :\n\n@PrepareForTest({ Lookup.class })\n\nLa ligne suivante est nécessaire car on n'utilise plus le runner MockitoJUnitRunner mais que l'on souhaite quand même utiliser les annotations Mocks et InjectMocks\n\nMockitoAnnotations.initMocks(this);\n\net enfin, le mock de la méthode statique :\n\nPowerMockito.mockStatic(Lookup.class);\nLookup lookup = mock(Lookup.class);\nwhen(Lookup.getInstance()).thenReturn(lookup );\n\nFacile non ?\n\nAllez, une petite dernière pour la route. Et si mon objet doit implémenter deux interfaces ? Par exemple j'utilise Carbon pour l'injection de dépendance (ok on sent le projet legacy là) et du coup tout mes beans doivent aussi implémenter l'interface Component.\n\nOuf, Mockito le gère depuis 2009 :\n\nmock(Lookup.class, withSettings().extraInterfaces(Component.class));\n\nVoila, vous en savez (peut-être) un peu plus sur Mockito, à vous de jouer maintenant !\n",readTime:{text:"5 min read",minutes:4.495,time:269700,words:899}},_img:{"/_ipx/_/hugo-nb.jpg":"\u002F_nuxt\u002Fimage\u002Fc3e54c.jpg"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a","strong",3,"h3","true",-1,"span","icon","icon-link","nofollow","noopener","noreferrer","_blank","li","mockito","mais-cest-quoi-mockito-","Mais c'est quoi Mockito ?","et-pourquoi-mockito-","Et pourquoi Mockito ?","et-pourquoi-powermock-","Et pourquoi Powermock ?","mais-revenons-aux-fondamentaux-pourquoi-utiliser-des-mocks-","Mais revenons aux fondamentaux, pourquoi utiliser des mocks ?","passons-à-la-pratique","Passons à la pratique","gérer-les-attributs-privés-sans-setters-","Gérer les attributs privés sans setters !","mocker-une-méthode-statique","Mocker une méthode statique","http:\u002F\u002Fmockito.org\u002F",".","http:\u002F\u002Ffchabanois.developpez.com\u002Ftutorial\u002Fjava\u002Fjmockit\u002F","2022-05-17T13:15:36.736Z")));