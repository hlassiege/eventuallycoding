__NUXT_JSONP__("/2013/08/16/fabric-moi-un-cluster", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L){return {data:[{article:{slug:"fabric-moi-un-cluster",description:"[![python](\u002Fimages\u002Fb9590-python.jpeg)](http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2013\u002F08\u002Fb9590-python.jpeg)Je vous propose dans ce billet de pren...",id:"904",title:"Fabric moi un cluster",date:"2013-08-16",categories:["waza"],tags:["devops","fabric",r],img:"b9590-python.jpeg",cover:"cover2.jpg",toc:[{id:s,depth:f,text:t},{id:u,depth:f,text:v},{id:w,depth:f,text:x},{id:y,depth:f,text:z},{id:A,depth:f,text:B},{id:C,depth:f,text:D},{id:E,depth:f,text:F},{id:G,depth:f,text:H}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{href:"http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2013\u002F08\u002Fb9590-python.jpeg",rel:[m,n,o],target:p},children:[{type:b,tag:"img",props:{alt:r,src:"\u002Fimages\u002Fb9590-python.jpeg"},children:[]}]},{type:a,value:"Je vous propose dans ce billet de prendre en main "},{type:b,tag:e,props:{href:"http:\u002F\u002Fdocs.fabfile.org\u002Fen\u002F1.7\u002F",rel:[m,n,o],target:p},children:[{type:a,value:"Fabric"}]},{type:a,value:", un outil que j’ai utilisé récemment et qui vous permettra de scripter des déploiements sur plusieurs machines assez simplement."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour résumer, Fabric est une lib Python qui vous permet d’automatiser des executions de commandes via ssh sur des serveurs distants."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En sus, Fabric permet de créer une topologie de votre application : quels sont les machines “web”, les machines “bases de données” etc..."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Grâce à ces infos, Fabric permet ensuite exécuter des scripts par famille de nœud. Par exemple installer la dernière version de votre Webapp sur tous les nœuds “web”."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Peut-être que si vous connaissiez déjà "},{type:b,tag:e,props:{href:"http:\u002F\u002Frundeck.org\u002F",rel:[m,n,o],target:p},children:[{type:a,value:"Rundeck"}]},{type:a,value:" tout ceci vous rappelle quelque chose puisqu’il répond a peu près à la même problématique."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Python Fabric est plus simple d’utilisation, vous ne retrouverez pas l’application Web qui permettait de gérer votre topologie et vous ne retrouverez pas les hooks qui permettaient de déclencher des actions. Mais vous allez voir qu’on y perd pas au change."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pourquoi Fabric et pas simplement faire du script Shell ? Nous le verrons dans la suite du billet."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et pour illustrer ce billet par un exemple de la vraie vie, vous trouverez à la fin de ce billet les sources pour installer un Cluster de 3 noeuds pour elasticsearch, MongoDB et Cassandra qui devraient fonctionner sous Debian."}]},{type:a,value:c},{type:b,tag:g,props:{id:s},children:[{type:b,tag:e,props:{href:"#installation",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"pip install fabric"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Oui, super complexe..."}]},{type:a,value:c},{type:b,tag:g,props:{id:u},children:[{type:b,tag:e,props:{href:"#mon-premier-script",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:v}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"(issu de la doc)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans un fichier nommé fabfile.py, écrire les lignes suivantes :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"from fabric.api import *"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\ndef host_type():\nrun('uname -s')"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Rien d’extraordinaire pour l’instant, nous allons juste executer cette commande sur des machines distantes."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"$ fab -H localhost,linuxbox host_type\n[localhost] run: uname -s\n[localhost] out: Darwin\n[linuxbox] run: uname -s\n[linuxbox] out: Linux\nDone.\nDisconnecting from localhost... done.\nDisconnecting from linuxbox... done."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La même chose avec un script shell :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"for machine in localhost linuxbox ; do ssh user@$machine \"uname -s\"; done"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Premier réflexe une fois qu’on connaît l’équivalent en shell, pourquoi pas du shell uniquement ? Voici mes raisons :"}]},{type:a,value:c},{type:b,tag:"ul",props:{},children:[{type:a,value:c},{type:b,tag:I,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"je préfère coder en Python (la raison la plus subjective :))"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:I,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"je ne réinvente pas la roue, les appels ssh, le parallélisme, la gestion des erreurs, les familles de noeuds, tout est déjà codé"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Voyons cela en détail."}]},{type:a,value:c},{type:b,tag:g,props:{id:w},children:[{type:b,tag:e,props:{href:"#le-parral%C3%A9lisme",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Changeons désormais notre méthode pour la remplacer par"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@parallel\ndef host_type():\nrun(‘uname -s’)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et lors de l’execution :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"$ fab -H localhost,linuxbox host_type\n[localhost] Executing task ‘host_type’\n[linuxbox] Executing task ‘host_type’\n[linuxbox] run: uname -s\n[localhost run: uname -s\n[linuxbox] out: Linux\n[linuxbox] out:\n[localhost] out: Darwin\n[localhost] out:"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Comme son nom l’indique, notre décorateur nous a permis de lancer notre commande en parallèle sur les hôtes passés en paramètre."}]},{type:a,value:c},{type:b,tag:g,props:{id:y},children:[{type:b,tag:e,props:{href:"#maintenir-une-topologie-de-n%C5%93uds",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:z}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Comme je le disais en intro Fabric permet de gérer des topologies applicatives."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Par exemple, nous allons définir 3 type de rôles :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"env.roledefs = {\n‘test’: ['localhost'],\n‘database’: ['"},{type:b,tag:e,props:{href:"mailto:root@xx.xx.xx.10"},children:[{type:a,value:"root@xx.xx.xx.10"}]},{type:a,value:q},{type:b,tag:e,props:{href:"mailto:root@xx.xx.xx.11"},children:[{type:a,value:"root@xx.xx.xx.11"}]},{type:a,value:q},{type:b,tag:e,props:{href:"mailto:root@xx.xx.xx.12"},children:[{type:a,value:"root@xx.xx.xx.12"}]},{type:a,value:"'],\n‘web’: ['"},{type:b,tag:e,props:{href:"mailto:root@xx.xx.xx.1"},children:[{type:a,value:"root@xx.xx.xx.1"}]},{type:a,value:q},{type:b,tag:e,props:{href:"mailto:root@xx.xx.xx.2"},children:[{type:a,value:"root@xx.xx.xx.2"}]},{type:a,value:q},{type:b,tag:e,props:{href:"mailto:root@xx.xx.xx.3"},children:[{type:a,value:"root@xx.xx.xx.3"}]},{type:a,value:"']\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et nous allons définir une tâche pour installer java uniquement sur les machines Web :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@parallel\n@roles(‘web’)\ndef java():\nrun(‘apt-get install openjdk-7-jdk –assume-yes’)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En tapant cette commande : fab java"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Fabric va lancer l’install de Java uniquement sur les machines de type “web”"}]},{type:a,value:c},{type:b,tag:g,props:{id:A},children:[{type:b,tag:e,props:{href:"#la-gestion-des-erreurs",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En réalité lorsque vous lancez une commande, il ne s’agit pas uniquement de lancer votre commande et basta. Vous espérez aussi que cela s’est bien passé. Fabric va vérifier cela pour vous en regardant le code retour de chaque opération. Exemple ici :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@roles(‘web’)\n@parallel\ndef something_wrong():\nrun(‘rm \u002Ftmp\u002Funknown_file’)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et l’execution"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"$ fab something_wrong\n[root@linuxbox] Executing task ‘something_wrong’\n[root@linuxbox] run: rm \u002Ftmp\u002Funknown_file\n[root@linuxbox] out: rm: impossible de supprimer « \u002Ftmp\u002Funknown_file »: Aucun fichier ou dossier de ce type\n[root@linuxbox] out:\nFatal error: run() received nonzero return code 1 while executing!\nRequested: rm \u002Ftmp\u002Funknown_file\nExecuted: \u002Fbin\u002Fbash -l -c « rm \u002Ftmp\u002Funknown_file »\nAborting."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Fatal error: One or more hosts failed while executing task ‘something_wrong’\nAborting."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Evidemment parfois on s’attend à une erreur, par exemple sur la tâche suivante :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@roles(‘database’)\n@parallel\ndef remove():\nrun(‘service mongodb stop’)\nrun(‘aptitude purge mongodb-10gen –assume-yes’)\nrun(‘rm -rf \u002Fvar\u002Flib\u002Fmongodb\u002F*’)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et si MongoDB n’est pas démarré ? C’est un cas normal et la désinstall doit tout de même se poursuivre."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans ce cas, on pourra ignorer l’erreur :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@roles(‘database’)\n@parallel\ndef remove():\nwith settings(warn_only=True):\nrun(‘service mongodb stop’)\nrun(‘aptitude purge mongodb-10gen –assume-yes’)\nrun(‘rm -rf \u002Fvar\u002Flib\u002Fmongodb\u002F*’)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Le décorateur @with_settings vous permettra d’ignorer les erreurs pour une tâche entière."}]},{type:a,value:c},{type:b,tag:g,props:{id:C},children:[{type:b,tag:e,props:{href:"#la-manipulation-de-fichier",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Plutôt fréquent dans une installation, vous devez modifier la configuration par défaut. Fabric vous propose plusieurs méthodes pour cela à base de sed."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La première, la plus simple dont on va se servir pour configurer le nom du cluster elasticsearch :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"sed('\u002Fetc\u002Felasticsearch\u002Felasticsearch.yml', '.*cluster.name:.*', 'cluster.name: eventuallycoding')"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Parfois cependant on a une logique plus alambiqué : si jamais la ligne n’existe pas tu la rajoutes, sinon tu la modifies (par exemple pour rajouter un dépot apt)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Fabric vous propose ceci :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"append('\u002Fetc\u002Fapt\u002Fsources.list.d\u002Fmongodb.list',\n           'deb "},{type:b,tag:e,props:{href:J,rel:[m,n,o],target:p},children:[{type:a,value:J}]},{type:a,value:" dist 10gen')"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La ligne ne sera pas ajouté si elle existe déjà. Et surtout le fichier sera créé s’il n’existait pas."}]},{type:a,value:c},{type:b,tag:g,props:{id:E},children:[{type:b,tag:e,props:{href:"#lordonnancement",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:F}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Il arrive régulièrement d’avoir une “super tâche” Fabric qui ordonnance une mise à jour sur l’ensemble des noeuds, par exemple Web et Database. Ce serait dommage de devoir scripter en shell les appels successifs aux tâches Fabric non ?"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Donc Fabric vous propose d’appeler des tâches à l’intérieur d’une tâche :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@roles('database')\ndef migrate():\n# Database stuff here.\npass"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\n@roles('web')\ndef update():\n# Code updates here.\npass"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"@task\ndef deploy():\nexecute(migrate)\nexecute(update)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La tâche deploy va lancer successivement les tâches migrate et update sur les bons noeuds de votre application."}]},{type:a,value:c},{type:b,tag:g,props:{id:G},children:[{type:b,tag:e,props:{href:"#la-modularisation",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:H}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour bien faire les choses, nous allons modulariser nos instructions d’installation. Ici je vais vous présenter un cas concret, l’installation d’un cluster MongoDB, d’un cluster ElasticSearch et d’un cluster Cassandra."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pas question évidemment d’avoir toutes les instructions dans un seul fichier fabfile. Nous allons donc créer : elasticsearch.py, mongodb.py, cassandra.py."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans notre fichier fabfile.py il nous suffira de faire :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"import mongodb, elasticsearch, cassandra"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"afin d’avoir accès à l’ensemble des tâches présentes pour chaque module."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et ensuite pour l’utilisateur, pour connaître la liste des tâches disponibles :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"$ fab -l\nAvailable commands:"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"install\ncassandra.install\ncassandra.start\ncassandra.stop\ncassandra.uninstall\nelasticsearch.install\nelasticsearch.uninstall\nelasticsearch.start\nelasticsearch.stop\njava.java\nmongodb.install\nmongodb.uninstall\nmongodb.start\nmongodb.stop"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et voilà. Comme tout outil de qualité qui se respecte, sa simplicité nous a permis d’en faire le tour rapidement."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En bonus vous pouvez aller voir ce repository github qui contient des scripts fabric pour installer MongoDB, ElasticSearch et Cassandra en cluster, chose dont j’ai eu besoin récemment pour réaliser des benchs sur les 3 (peut être un futur billet) :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{href:K,rel:[m,n,o],target:p},children:[{type:a,value:K}]}]}]},dir:"\u002Farticles\u002F2013\u002F08\u002F16",path:"\u002Farticles\u002F2013\u002F08\u002F16\u002Ffabric-moi-un-cluster",extension:".md",createdAt:L,updatedAt:L,bodyPlainText:"\npythonJe vous propose dans ce billet de prendre en main Fabric, un outil que j’ai utilisé récemment et qui vous permettra de scripter des déploiements sur plusieurs machines assez simplement.\n\nPour résumer, Fabric est une lib Python qui vous permet d’automatiser des executions de commandes via ssh sur des serveurs distants.\n\nEn sus, Fabric permet de créer une topologie de votre application : quels sont les machines “web”, les machines “bases de données” etc...\n\nGrâce à ces infos, Fabric permet ensuite exécuter des scripts par famille de nœud. Par exemple installer la dernière version de votre Webapp sur tous les nœuds “web”.\n\nPeut-être que si vous connaissiez déjà Rundeck tout ceci vous rappelle quelque chose puisqu’il répond a peu près à la même problématique.\n\nPython Fabric est plus simple d’utilisation, vous ne retrouverez pas l’application Web qui permettait de gérer votre topologie et vous ne retrouverez pas les hooks qui permettaient de déclencher des actions. Mais vous allez voir qu’on y perd pas au change.\n\nPourquoi Fabric et pas simplement faire du script Shell ? Nous le verrons dans la suite du billet.\n\nEt pour illustrer ce billet par un exemple de la vraie vie, vous trouverez à la fin de ce billet les sources pour installer un Cluster de 3 noeuds pour elasticsearch, MongoDB et Cassandra qui devraient fonctionner sous Debian.\n\nInstallation\n\npip install fabric\n\nOui, super complexe...\n\nMon premier script\n\n(issu de la doc)\n\nDans un fichier nommé fabfile.py, écrire les lignes suivantes :\n\nfrom fabric.api import \\*\n\n@task\ndef host\\_type():\n    run('uname -s')\n\nRien d’extraordinaire pour l’instant, nous allons juste executer cette commande sur des machines distantes.\n\n$ fab -H localhost,linuxbox host\\_type\n\\[localhost\\] run: uname -s\n\\[localhost\\] out: Darwin\n\\[linuxbox\\] run: uname -s\n\\[linuxbox\\] out: Linux\nDone.\nDisconnecting from localhost... done.\nDisconnecting from linuxbox... done.\n\nLa même chose avec un script shell :\n\nfor machine in localhost linuxbox ; do ssh user@$machine \"uname -s\"; done\n\nPremier réflexe une fois qu’on connaît l’équivalent en shell, pourquoi pas du shell uniquement ? Voici mes raisons :\n\nje préfère coder en Python (la raison la plus subjective :))\n\nje ne réinvente pas la roue, les appels ssh, le parallélisme, la gestion des erreurs, les familles de noeuds, tout est déjà codé\n\n\nVoyons cela en détail.\n\nLe parralélisme\n\nChangeons désormais notre méthode pour la remplacer par\n\n@task\n@parallel\ndef host\\_type():\n    run(‘uname -s’)\n\nEt lors de l’execution :\n\n$ fab -H localhost,linuxbox host\\_type\n\\[localhost\\] Executing task ‘host\\_type’\n\\[linuxbox\\] Executing task ‘host\\_type’\n\\[linuxbox\\] run: uname -s\n\\[localhost run: uname -s\n\\[linuxbox\\] out: Linux\n\\[linuxbox\\] out:\n\\[localhost\\] out: Darwin\n\\[localhost\\] out:\n\nComme son nom l’indique, notre décorateur nous a permis de lancer notre commande en parallèle sur les hôtes passés en paramètre.\n\nMaintenir une topologie de nœuds\n\nComme je le disais en intro Fabric permet de gérer des topologies applicatives.\n\nPar exemple, nous allons définir 3 type de rôles :\n\nenv.roledefs = {\n‘test’: \\['localhost'\\],\n‘database’: \\['root@xx.xx.xx.10', 'root@xx.xx.xx.11', 'root@xx.xx.xx.12'\\],\n‘web’: \\['root@xx.xx.xx.1', 'root@xx.xx.xx.2', 'root@xx.xx.xx.3'\\]\n}\n\nEt nous allons définir une tâche pour installer java uniquement sur les machines Web :\n\n@task\n@parallel\n@roles(‘web’)\ndef java():\n    run(‘apt-get install openjdk-7-jdk –assume-yes’)\n\nEn tapant cette commande : fab java\n\nFabric va lancer l’install de Java uniquement sur les machines de type “web”\n\nLa gestion des erreurs\n\nEn réalité lorsque vous lancez une commande, il ne s’agit pas uniquement de lancer votre commande et basta. Vous espérez aussi que cela s’est bien passé. Fabric va vérifier cela pour vous en regardant le code retour de chaque opération. Exemple ici :\n\n@task\n@roles(‘web’)\n@parallel\ndef something\\_wrong():\n    run(‘rm \u002Ftmp\u002Funknown\\_file’)\n\nEt l’execution\n\n$ fab something\\_wrong\n\\[root@linuxbox\\] Executing task ‘something\\_wrong’\n\\[root@linuxbox\\] run: rm \u002Ftmp\u002Funknown\\_file\n\\[root@linuxbox\\] out: rm: impossible de supprimer « \u002Ftmp\u002Funknown\\_file »: Aucun fichier ou dossier de ce type\n\\[root@linuxbox\\] out:\nFatal error: run() received nonzero return code 1 while executing!\nRequested: rm \u002Ftmp\u002Funknown\\_file\nExecuted: \u002Fbin\u002Fbash -l -c « rm \u002Ftmp\u002Funknown\\_file »\nAborting.\n\nFatal error: One or more hosts failed while executing task ‘something\\_wrong’\nAborting.\n\nEvidemment parfois on s’attend à une erreur, par exemple sur la tâche suivante :\n\n@task\n@roles(‘database’)\n@parallel\ndef remove():\n    run(‘service mongodb stop’)\n    run(‘aptitude purge mongodb-10gen –assume-yes’)\n    run(‘rm -rf \u002Fvar\u002Flib\u002Fmongodb\u002F\\*’)\n\nEt si MongoDB n’est pas démarré ? C’est un cas normal et la désinstall doit tout de même se poursuivre.\n\nDans ce cas, on pourra ignorer l’erreur :\n\n@task\n@roles(‘database’)\n@parallel\ndef remove():\n    with settings(warn\\_only=True):\n        run(‘service mongodb stop’)\n    run(‘aptitude purge mongodb-10gen –assume-yes’)\n    run(‘rm -rf \u002Fvar\u002Flib\u002Fmongodb\u002F\\*’)\n\nLe décorateur @with\\_settings vous permettra d’ignorer les erreurs pour une tâche entière.\n\nLa manipulation de fichier\n\nPlutôt fréquent dans une installation, vous devez modifier la configuration par défaut. Fabric vous propose plusieurs méthodes pour cela à base de sed.\n\nLa première, la plus simple dont on va se servir pour configurer le nom du cluster elasticsearch :\n\nsed('\u002Fetc\u002Felasticsearch\u002Felasticsearch.yml', '.\\cluster.name:.\\', 'cluster.name: eventuallycoding')\n\nParfois cependant on a une logique plus alambiqué : si jamais la ligne n’existe pas tu la rajoutes, sinon tu la modifies (par exemple pour rajouter un dépot apt).\n\nFabric vous propose ceci :\n\nappend('\u002Fetc\u002Fapt\u002Fsources.list.d\u002Fmongodb.list',\n           'deb http:\u002F\u002Fdownloads-distro.mongodb.org\u002Frepo\u002Fdebian-sysvinit dist 10gen')\n\nLa ligne ne sera pas ajouté si elle existe déjà. Et surtout le fichier sera créé s’il n’existait pas.\n\nL’ordonnancement\n\nIl arrive régulièrement d’avoir une “super tâche” Fabric qui ordonnance une mise à jour sur l’ensemble des noeuds, par exemple Web et Database. Ce serait dommage de devoir scripter en shell les appels successifs aux tâches Fabric non ?\n\nDonc Fabric vous propose d’appeler des tâches à l’intérieur d’une tâche :\n\n@task\n@roles('database')\ndef migrate():\nDatabase stuff here.\n    pass\n\n@task\n@roles('web')\ndef update():\nCode updates here.\n    pass\n\n@task\ndef deploy():\n    execute(migrate)\n    execute(update)\n\nLa tâche deploy va lancer successivement les tâches migrate et update sur les bons noeuds de votre application.\n\nLa modularisation\n\nPour bien faire les choses, nous allons modulariser nos instructions d’installation. Ici je vais vous présenter un cas concret, l’installation d’un cluster MongoDB, d’un cluster ElasticSearch et d’un cluster Cassandra.\n\nPas question évidemment d’avoir toutes les instructions dans un seul fichier fabfile. Nous allons donc créer : elasticsearch.py, mongodb.py, cassandra.py.\n\nDans notre fichier fabfile.py il nous suffira de faire :\n\nimport mongodb, elasticsearch, cassandra\n\nafin d’avoir accès à l’ensemble des tâches présentes pour chaque module.\n\nEt ensuite pour l’utilisateur, pour connaître la liste des tâches disponibles :\n\n$ fab -l\nAvailable commands:\n\ninstall\ncassandra.install\ncassandra.start\ncassandra.stop\ncassandra.uninstall\nelasticsearch.install\nelasticsearch.uninstall\nelasticsearch.start\nelasticsearch.stop\njava.java\nmongodb.install\nmongodb.uninstall\nmongodb.start\nmongodb.stop\n\nEt voilà. Comme tout outil de qualité qui se respecte, sa simplicité nous a permis d’en faire le tour rapidement.\n\nEn bonus vous pouvez aller voir ce repository github qui contient des scripts fabric pour installer MongoDB, ElasticSearch et Cassandra en cluster, chose dont j’ai eu besoin récemment pour réaliser des benchs sur les 3 (peut être un futur billet) :\n\nhttps:\u002F\u002Fgithub.com\u002Fhlassiege\u002Ffabric-sample\n",readTime:{text:"6 min read",minutes:5.595,time:335700,words:1119}},_img:{"/_ipx/_/hugo-nb.jpg":"\u002F_nuxt\u002Fimage\u002Fc3e54c.jpg"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a",2,"h2","true",-1,"span","icon","icon-link","nofollow","noopener","noreferrer","_blank","', '","python","installation","Installation","mon-premier-script","Mon premier script","le-parralélisme","Le parralélisme","maintenir-une-topologie-de-nœuds","Maintenir une topologie de nœuds","la-gestion-des-erreurs","La gestion des erreurs","la-manipulation-de-fichier","La manipulation de fichier","lordonnancement","L’ordonnancement","la-modularisation","La modularisation","li","http:\u002F\u002Fdownloads-distro.mongodb.org\u002Frepo\u002Fdebian-sysvinit","https:\u002F\u002Fgithub.com\u002Fhlassiege\u002Ffabric-sample","2022-05-19T06:48:34.325Z")));