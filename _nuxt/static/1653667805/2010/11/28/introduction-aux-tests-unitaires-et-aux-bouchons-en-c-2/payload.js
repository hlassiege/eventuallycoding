__NUXT_JSONP__("/2010/11/28/introduction-aux-tests-unitaires-et-aux-bouchons-en-c-2", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq){return {data:[{article:{slug:"introduction-aux-tests-unitaires-et-aux-bouchons-en-c-2",description:"Par définition (Cf. [Wikipédia](http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FTest_unitaire) ) un test unitaire est un procédé permettant de s'assurer du fonctionnemen...",id:"144",title:"Introduction aux tests unitaires et aux bouchons en C#",date:I,categories:["waza"],tags:[z,J],img:"",cover:"cover5.jpg",toc:[{id:K,depth:q,text:L},{id:M,depth:q,text:N},{id:O,depth:q,text:P},{id:Q,depth:q,text:R},{id:S,depth:q,text:T},{id:U,depth:q,text:V},{id:W,depth:C,text:X},{id:Y,depth:C,text:Z},{id:_,depth:C,text:$},{id:aa,depth:q,text:ab},{id:ac,depth:q,text:ad},{id:ae,depth:q,text:af}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:a,value:"Par définition (Cf. "},{type:b,tag:e,props:{href:"http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FTest_unitaire",rel:[u,v,w],target:x},children:[{type:a,value:"Wikipédia"}]},{type:a,value:" ) un test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme (appelée « unité » ou « module »)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Un test est dit "},{type:b,tag:s,props:{},children:[{type:a,value:"unitaire"}]},{type:a,value:" s'il ne fait pas appel à d'autres ressources que la classe testé. Un test unitaire n'utilise donc pas de base de données, de socket, MQ series etc... à l'inverse d'un test d'intégration."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Un test d'"},{type:b,tag:s,props:{},children:[{type:a,value:"intégration"}]},{type:a,value:" est donc par extension un test qui peut utiliser des ressources externes : bases de données par exemple."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Voyons ce que ça donne en C#."}]},{type:a,value:c},{type:b,tag:r,props:{id:K},children:[{type:b,tag:e,props:{href:"#%C3%A9criture-dun-premier-test",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:L}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Par convention, une classe de test correspond généralement aux tests d'une classe de votre code."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:s,props:{},children:[{type:a,value:"Exemple"}]},{type:a,value:" :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"votre classe : "},{type:b,tag:D,props:{},children:[{type:a,value:"EmailAdressValidator"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public class  EmailAddressValidator\n{\nprivate DomainValidator domainValidator;"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n        return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n    ...\npublic bool CheckDomainExists(string domain)\n{\n        return  domainValidator.Exists(domain);\n}\n...\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:E}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"la classe de test : "},{type:b,tag:D,props:{},children:[{type:a,value:"EmailAdressValidatorTest"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Une classe de test comporte un stéréotype TestFixture, les méthodes de test ont un stéréotype Test."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"[TestFixture]\npublic class EmailValidatorTest\n{\nEmailAddressValidator EAV;"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"\\[SetUp\\]\npublic void SetUp()\n{\n    EAV = new EmailAddressValidator ();\n}\n\n\\[TearDown\\]\npublic void TearDown()\n{\n    EVA.Clean();\n}\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"[Test]\npublic void TestEmailSyntaxArobas()\n{\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\""},{type:b,tag:e,props:{href:F},children:[{type:a,value:G}]},{type:a,value:"\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\nAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n}\n}"}]},{type:a,value:c},{type:b,tag:r,props:{id:M},children:[{type:b,tag:e,props:{href:"#diff%C3%A9rentes-assertions",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:N}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans un test, on cherche toujours à vérifier un comportement. On utilise donc des assertions, ces assertions définissent le comportement attendu."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En francais, une assertion est un énoncé considéré comme vrai."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour un test unitaire, il s'agit d'une expression qui doit être vrai pour que le test réussisse."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"NUnit et MBunit utilise une classe statique "},{type:b,tag:e,props:{href:ag,rel:[u,v,w],target:x},children:[{type:a,value:ah}]},{type:a,value:" pour les assertions :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Cette classe "},{type:b,tag:e,props:{href:ag,rel:[u,v,w],target:x},children:[{type:a,value:ah}]},{type:a,value:" va nous permettre de tester entre autre :"}]},{type:a,value:c},{type:b,tag:A,props:{},children:[{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"l'égalité : Assert.Equals"}]},{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"le non null : Assert.IsNotNull"}]},{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"une condition Assert.IsTrue"},{type:b,tag:B,props:{},children:[]},{type:a,value:"\nmais aussi, la présence dans une plage de valeur, une égalité approximative, l'égalité des références etc..."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Un test comporte toujours des assertions."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002F CheckEmailAdressSyntax doit renvoyer true avec le paramètre \""},{type:b,tag:e,props:{href:F},children:[{type:a,value:G}]},{type:a,value:"\"\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\""},{type:b,tag:e,props:{href:F},children:[{type:a,value:G}]},{type:a,value:"\"));"}]},{type:a,value:c},{type:b,tag:r,props:{id:O},children:[{type:b,tag:e,props:{href:"#setupteardown",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:P}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Il est parfois nécessaire d'effectuer des opérations avant et après chaque test. Une classe peut donc définir des méthodes appelées avant et après chaque test avec les stéréotypes Setup et Teardown."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002F toujours exécuté avant les tests\n[SetUp]\npublic void SetUp()\n{\nEAV = new EmailAddressValidator ();\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002F toujours exécuté après les tests\n[TearDown]\npublic void TearDown()\n{\nEVA.Clean();\n}"}]},{type:a,value:c},{type:b,tag:r,props:{id:Q},children:[{type:b,tag:e,props:{href:"#la-couverture-de-code",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:R}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La "},{type:b,tag:s,props:{},children:[{type:a,value:"couverture de code"}]},{type:a,value:" est une métrique utilisée en génie logiciel pour décrire le taux de code source "},{type:b,tag:e,props:{href:ai,rel:[u,v,w],target:x},children:[{type:a,value:ai}]},{type:a,value:" testé d'un programme. Ceci permet de mesurer la qualité des tests effectués."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En .NET on utilise "},{type:b,tag:e,props:{href:aj,rel:[u,v,w],target:x},children:[{type:a,value:ak}]},{type:a,value:" pour mesurer cette couverture de code. "},{type:b,tag:e,props:{href:aj,rel:[u,v,w],target:x},children:[{type:a,value:ak}]},{type:a,value:" va calculer à partir des tests joués et du code initial l'ensemble des chemins qui ont été parcourus et fournir un pourcentage du code parcouru par rapport au code non parcouru."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ci-dessous, un exemple des rapports proposés par NCover :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"XXXX"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans les tests précédents, NCover remarque que l'on ne passe pas par "},{type:b,tag:s,props:{},children:[{type:a,value:"CheckDomainExists"}]},{type:a,value:" que l'on verra plus bas sur cette page. De plus le test sur la nullité de la chaine entrée n'est jamais évalué à true :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"if(emailAddress == null )\n{\nthrow new NullReferenceException();\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Un test avec une chaine null ferait remonter la couverture de code."}]},{type:a,value:c},{type:b,tag:r,props:{id:S},children:[{type:b,tag:e,props:{href:"#test-param%C3%A9tr%C3%A9",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:T}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans le test précédent, on réécrit x fois la même ligne pour tester avec des paramètres différents :"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Premier défaut à cette méthode :"}]},{type:a,value:c},{type:b,tag:A,props:{},children:[{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"il est conseillé d'avoir une assertion par méthode de test, ca permet d'être sur que tout les cas de test sont joués (sinon la première erreur empêche l'execution des autres tests)."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:y}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"\\[Test\\]\npublic void TestInvalidEmailSyntaxWithTwoArobas()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n}\n\n\\[Test\\]\npublic void TestInvalidEmailSyntaxWithoutName()\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n}\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Second défaut, on duplique le code testé. Cela aurait été plus gênant avec un code sur plusieurs lignes."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Solution :"},{type:b,tag:B,props:{},children:[]},{type:a,value:"\nPour éviter de réécrire x fois le même test avec des paramètres différents, on va utiliser des tests paramétrés :"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"\\[Test\\]\n\\[Row(\"Nom@@entreprise.com\")\\]\n\\[Row(\"Nomentreprise.com\")\\]\n\\[Row(\"@entreprise.com\")\\]\n\\[Row(\"Nom@\")\\]\npublic void TestEmailSyntaxArobas(string name)\n{\n    Assert.IsFalse(EAV.CheckEmailAddressSyntax (name));\n}\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Le même test est joué 4 fois pour chaque valeur de paramètre. L'attribut Row est utilisé pour chaque paramétre et celui-ci est passé en paramètre de la méthode."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Autre exemple avec un code plus complexe :"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"\\[Test\\]\n\\[Row(\"Milou\")\\]\n\\[Row(\"Idefix\")\\]\npublic void TestWithFakeAndRowTest(string name)\n{\n    \u002F\u002F \"Setup\" (initialisation des objets pour le test)\n    OrderWriter orderWriter = new OrderWriter(new FakeWriter());\n    Order order = new Order() { OrderId = 7001, Pet = new Dog(name) };\n\n    \u002F\u002F \"Execute\" (Exécution du test : écriture de l'ordre sur le système)\n    orderWriter.WriteOrder(order);\n\n    \u002F\u002F \"State verification\" (vérification de l'état de l'objet par des assertions)\n    Assert.AreEqual(name, order.Pet.Name);\n    Assert.IsTrue(order.IsFilled);\n}\n"}]}]}]},{type:a,value:c},{type:b,tag:r,props:{id:U},children:[{type:b,tag:e,props:{href:"#le-bouchonnage",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:V}]},{type:a,value:c},{type:b,tag:H,props:{id:W},children:[{type:b,tag:e,props:{href:"#probl%C3%A9matique",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:X}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Comme dit plus haut, un test unitaire doit être indépendant des ressources externes : base de données, file de message etc..."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Mais il arrive souvent que l'on utilise ces ressources dans les classes testées."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public class  EmailAddressValidator\n{\nDomainValidator domainValidator;"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"public EmailAddressValidator()\n{\n    DomainValidator domainValidator = new DomainValidator();\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(emailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}...\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:E}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ici le DomainValidator fait appel à un service web pour vérifier l'existence d'un nom de domaine. Le test unitaire de la méthode CheckDomainExists pose donc problème."}]},{type:a,value:c},{type:b,tag:H,props:{id:Y},children:[{type:b,tag:e,props:{href:"#solution",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:Z}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La solution consiste à utiliser un bouchon à la place du DomainValidator."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour cela, un peu de remaniement de code est nécessaire ("},{type:b,tag:D,props:{},children:[{type:a,value:"refactoring"}]},{type:a,value:al}]},{type:a,value:c},{type:b,tag:A,props:{},children:[{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"l'objet DomainValidator n'est plus instancié dans le constructeur mais injecté par constructeur ou par mutateur (propriété)"}]},{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"On utilise une interface à la place de l'objet réel pour \"inverser la dépendance\" de la classe EmailAdressValidator non plus sur la classe \"DomainValidator\" mais sur une interface \"IDomainValidator\""}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Exemple avec injection par constructeur :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002F Interface IDomainValidator\npublic interface IDomainValidator\n{\nbool Exists(string sDomain);\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002F Classe à tester\nclass  EmailAddressValidator\n{\n\u002F\u002F Interface\nprivate readonly IDomainValidator domainValidator;"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"public EmailAddressValidator(IDomainValidator domainValidator)\n{\n    this.domainValidator = domainValidator;\n}\n\npublic bool CheckEmailAddressSyntax(string emailAddress)\n{\n    if(sEmailAddress == null )\n    {\n        throw new NullReferenceException();\n    }\n    return Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n}\n...\npublic bool CheckDomainExists(string domain)\n{\n    return  domainValidator.Exists(domain);\n}\n...\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:E}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Exemple avec injection par mutatteur (propriété getter\u002Fsetter) :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002F Classe à tester\nclass  EmailAddressValidator\n{\n\u002F\u002F Interface\npublic IDomainValidator domainValidator { get; set; }"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public EmailAddressValidator()\n{\n}\n...."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"A partir de là, il faut écrire une implémentation de IDomainValidator valable uniquement pour le test."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"class FakeDomainValidator : IDomainValidator\n{\npublic bool Exists(string sDomain)\n{\nreturn true;\n}\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:s,props:{},children:[{type:a,value:"Les tests de EmailAddressValidator pourront donc être indépendants de l'implémentation de IDomainValidator."}]}]},{type:a,value:c},{type:b,tag:H,props:{id:_},children:[{type:b,tag:e,props:{href:"#limitations",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:$}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Si vous souhaitez tester le comportement de EmailAddressValidator dans le cas d'un retour true et false, il faut écrire deux bouchons."},{type:b,tag:B,props:{},children:[]},{type:a,value:"\nSi l'objet est complexe et contient plus de 3 méthodes, l'écriture des bouchons est rapidement fastidieuse."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour cela, il faut utiliser des outils qui génèrent les bouchons dynamiquement. Voir partie suivante sur les mocks."}]},{type:a,value:c},{type:b,tag:"h1",props:{id:"présentation-des-mocks"},children:[{type:b,tag:e,props:{href:"#pr%C3%A9sentation-des-mocks",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:"Présentation des Mocks"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Les Mocks permettent de s'affranchir de l'écriture des bouchons cités plus haut. Deux lignes de code suffisent pour créer une implémentation vide d'une interface :"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"  var mock = new Mock();\n  IDomainValidator domainValidatorMock = mock.Object;\n"}]}]}]},{type:a,value:c},{type:b,tag:r,props:{id:aa},children:[{type:b,tag:e,props:{href:"#mocks-pour-tester-l%C3%A9tat-des-objets",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:ab}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"On peut désormais écrire :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"EAV = new EmailAddressValidator ();\nEAV.domainValidator = domainValidatorMock;\nEAV.CheckDomainExists(\"domaine.fr\");"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Par défaut, nous n'avons pas défini ce que devait renvoyer Exists de domainValidatorMock, donc la méthode va renvoyer false (la valeur d'un bool par défaut)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:s,props:{},children:[{type:a,value:"Ici, on va donc tester la méthode CheckDomainExists de EmailAddressValidator sans faire d'appel à un web service."}]}]},{type:a,value:c},{type:b,tag:r,props:{id:ac},children:[{type:b,tag:e,props:{href:"#pr%C3%A9ciser-le-comportement-du-mock",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:ad}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans l'exemple précédent, on va coder deux tests, un ou le résultat du IDomainValidator est false, l'autre ou c'est true. Pour cela, on va initialiser le mock avec la méthode Setup :"}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"    \\[Test\\]\n    public void TestDomainExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(true);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n\n    \\[Test\\]\n    public void TestDomainNotExist()\n    {\n        EAV = new EmailAddressValidator ();\n        EAV.domainValidator = domainValidatorMock;\n        mock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(false);\n        Assert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n    }\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La méthode Setup prend une lambda expression indiquant le comportement attendu de la méthode Exists sur l'objet."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"On remarque l'utilisation de It.IsAny"},{type:b,tag:"string",props:{},children:[{type:a,value:"() qui indique que l'appel de Exists avec n'importe quel string renverra true."}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Tout le comportement de la méthode bouchonnée peut être précisé comme cela."},{type:b,tag:B,props:{},children:[]},{type:a,value:"\nPar exemple si la méthode doit renvoyer une exception :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"mock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(false).Throws(new ArgumentException(\"invalid argument\"));"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"On peut indiquer que l'appel de la méthode doit ensuite déclencher une fonction de rappel :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"mock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(false).Callback(() =\u003E MethodToCall());"}]},{type:a,value:c},{type:b,tag:r,props:{id:ae},children:[{type:b,tag:e,props:{href:"#mock-pour-tester-le-comportement-des-objets",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:af}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En réalité il existe deux types de tests à faire :"}]},{type:a,value:c},{type:b,tag:A,props:{},children:[{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"tester que EmailAdressValidator se comporte bien"}]},{type:a,value:c},{type:b,tag:t,props:{},children:[{type:a,value:"tester que DomainValidator est correctement appelé par EmailAdressValidator"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"pour le deuxième type de test, le mock peut ajouter des attentes (ou "},{type:b,tag:s,props:{},children:[{type:a,value:"expectations"}]},{type:a,value:al}]},{type:a,value:c},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,o]},children:[{type:b,tag:p,props:{},children:[{type:a,value:"        \u002F\u002F \"Behavior verification\" (vérifications du comportement de l'objet par des attentes)\n        mock.Verify(foo =\u003E foo.Exists(It.IsAny())).Returns(false), Times.AtMostOnce(),\n        \"Fail message: method IDomainValidator.Existsshould be called and called only once\");\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ici par exemple on vérifie que la méthode Exists ne peut être appelé qu'une seule fois."}]}]},dir:"\u002Farticles\u002F2010\u002F11\u002F28",path:"\u002Farticles\u002F2010\u002F11\u002F28\u002Fintroduction-aux-tests-unitaires-et-aux-bouchons-en-c-2",extension:".md",createdAt:am,updatedAt:am,bodyPlainText:"\nPar définition (Cf. Wikipédia ) un test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme (appelée « unité » ou « module »).\n\nUn test est dit unitaire s'il ne fait pas appel à d'autres ressources que la classe testé. Un test unitaire n'utilise donc pas de base de données, de socket, MQ series etc... à l'inverse d'un test d'intégration.\n\nUn test d'intégration est donc par extension un test qui peut utiliser des ressources externes : bases de données par exemple.\n\nVoyons ce que ça donne en C#.\n\nÉcriture d'un premier test\n\nPar convention, une classe de test correspond généralement aux tests d'une classe de votre code.\n\nExemple :\n\nvotre classe : EmailAdressValidator\n\nExemple :\n\npublic class  EmailAddressValidator\n{\n\tprivate DomainValidator domainValidator;\n\n\tpublic EmailAddressValidator()\n\t{\n\t\tDomainValidator domainValidator = new DomainValidator();\n\t}\n\n\tpublic bool CheckEmailAddressSyntax(string emailAddress)\n\t{\n\t\tif(emailAddress == null )\n\t\t{\n\t\t\tthrow new NullReferenceException();\n\t\t}\n\t\t\treturn Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n\t}\n\t\t...\n\tpublic bool CheckDomainExists(string domain)\n\t{\n\t\t\treturn  domainValidator.Exists(domain);\n\t}\n\t...\n}\n\nla classe de test : EmailAdressValidatorTest\n\nUne classe de test comporte un stéréotype TestFixture, les méthodes de test ont un stéréotype Test.\n\nExemple :\n\n\\[TestFixture\\]\npublic class EmailValidatorTest\n{\n\tEmailAddressValidator EAV;\n\n\t\\[SetUp\\]\n\tpublic void SetUp()\n\t{\n\t\tEAV = new EmailAddressValidator ();\n\t}\n\n\t\\[TearDown\\]\n\tpublic void TearDown()\n\t{\n\t\tEVA.Clean();\n\t}\n\n   \\[Test\\]\n   public void TestEmailSyntaxArobas()\n   {\n\t   Assert.IsTrue(EAV.CheckEmailAddressSyntax (\"Nom@entreprise.com\"));\n\t   Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n\t   Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n\t   Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n\t   Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n   }\n}\n\nDifférentes assertions\n\nDans un test, on cherche toujours à vérifier un comportement. On utilise donc des assertions, ces assertions définissent le comportement attendu.\n\nEn francais, une assertion est un énoncé considéré comme vrai.\n\nPour un test unitaire, il s'agit d'une expression qui doit être vrai pour que le test réussisse.\n\nNUnit et MBunit utilise une classe statique Assert pour les assertions :\n\nCette classe Assert va nous permettre de tester entre autre :\n\nl'égalité : Assert.Equals\nle non null : Assert.IsNotNull\nune condition Assert.IsTrue\n    mais aussi, la présence dans une plage de valeur, une égalité approximative, l'égalité des références etc...\n\nUn test comporte toujours des assertions.\n\nExemple :\n\n\u002F\u002F CheckEmailAdressSyntax doit renvoyer true avec le paramètre \"Nom@entreprise.com\"\nAssert.IsTrue(EAV.CheckEmailAddressSyntax (\"Nom@entreprise.com\"));\n\nSetup\u002FTearDown\n\nIl est parfois nécessaire d'effectuer des opérations avant et après chaque test. Une classe peut donc définir des méthodes appelées avant et après chaque test avec les stéréotypes Setup et Teardown.\n\nExemple :\n\n   \u002F\u002F toujours exécuté avant les tests\n   \\[SetUp\\]\n   public void SetUp()\n   {\n\t\tEAV = new EmailAddressValidator ();\n   }\n\n   \u002F\u002F toujours exécuté après les tests\n   \\[TearDown\\]\n   public void TearDown()\n   {\n\t\tEVA.Clean();\n   }\n\nLa couverture de code\n\nLa couverture de code est une métrique utilisée en génie logiciel pour décrire le taux de code source http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FCode\\_source testé d'un programme. Ceci permet de mesurer la qualité des tests effectués.\n\nEn .NET on utilise NCover pour mesurer cette couverture de code. NCover va calculer à partir des tests joués et du code initial l'ensemble des chemins qui ont été parcourus et fournir un pourcentage du code parcouru par rapport au code non parcouru.\n\nCi-dessous, un exemple des rapports proposés par NCover :\n\nXXXX\n\nDans les tests précédents, NCover remarque que l'on ne passe pas par CheckDomainExists que l'on verra plus bas sur cette page. De plus le test sur la nullité de la chaine entrée n'est jamais évalué à true :\n\nif(emailAddress == null )\n{\n\tthrow new NullReferenceException();\n}\n\nUn test avec une chaine null ferait remonter la couverture de code.\n\nTest paramétré\n\nDans le test précédent, on réécrit x fois la même ligne pour tester avec des paramètres différents :\n\n      Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n\t  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nomentreprise.com\"));\n\t  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n\t  Assert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@\"));\n\nPremier défaut à cette méthode :\n\nil est conseillé d'avoir une assertion par méthode de test, ca permet d'être sur que tout les cas de test sont joués (sinon la première erreur empêche l'execution des autres tests).\n\nExemple :\n\n\t\\[Test\\]\n\tpublic void TestInvalidEmailSyntaxWithTwoArobas()\n\t{\n\t\tAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"Nom@@entreprise.com\"));\n\t}\n\n\t\\[Test\\]\n\tpublic void TestInvalidEmailSyntaxWithoutName()\n\t{\n\t\tAssert.IsFalse(EAV.CheckEmailAddressSyntax (\"@entreprise.com\"));\n\t}\n\nSecond défaut, on duplique le code testé. Cela aurait été plus gênant avec un code sur plusieurs lignes.\n\nSolution :\nPour éviter de réécrire x fois le même test avec des paramètres différents, on va utiliser des tests paramétrés :\n\n\t\\[Test\\]\n\t\\[Row(\"Nom@@entreprise.com\")\\]\n\t\\[Row(\"Nomentreprise.com\")\\]\n\t\\[Row(\"@entreprise.com\")\\]\n\t\\[Row(\"Nom@\")\\]\n\tpublic void TestEmailSyntaxArobas(string name)\n\t{\n\t\tAssert.IsFalse(EAV.CheckEmailAddressSyntax (name));\n\t}\n\nLe même test est joué 4 fois pour chaque valeur de paramètre. L'attribut Row est utilisé pour chaque paramétre et celui-ci est passé en paramètre de la méthode.\n\nAutre exemple avec un code plus complexe :\n\n\t\\[Test\\]\n\t\\[Row(\"Milou\")\\]\n\t\\[Row(\"Idefix\")\\]\n\tpublic void TestWithFakeAndRowTest(string name)\n\t{\n\t\t\u002F\u002F \"Setup\" (initialisation des objets pour le test)\n\t\tOrderWriter orderWriter = new OrderWriter(new FakeWriter());\n\t\tOrder order = new Order() { OrderId = 7001, Pet = new Dog(name) };\n\n\t\t\u002F\u002F \"Execute\" (Exécution du test : écriture de l'ordre sur le système)\n\t\torderWriter.WriteOrder(order);\n\n\t\t\u002F\u002F \"State verification\" (vérification de l'état de l'objet par des assertions)\n\t\tAssert.AreEqual(name, order.Pet.Name);\n\t\tAssert.IsTrue(order.IsFilled);\n\t}\n\nLe bouchonnage\n\nProblématique\n\nComme dit plus haut, un test unitaire doit être indépendant des ressources externes : base de données, file de message etc...\n\nMais il arrive souvent que l'on utilise ces ressources dans les classes testées.\n\nExemple :\n\npublic class  EmailAddressValidator\n{\n\tDomainValidator domainValidator;\n\n\tpublic EmailAddressValidator()\n\t{\n\t\tDomainValidator domainValidator = new DomainValidator();\n\t}\n\n\tpublic bool CheckEmailAddressSyntax(string emailAddress)\n\t{\n\t\tif(emailAddress == null )\n\t\t{\n\t\t\tthrow new NullReferenceException();\n\t\t}\n\t\treturn Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n\t}\n\t...\n\tpublic bool CheckDomainExists(string domain)\n\t{\n\t\treturn  domainValidator.Exists(domain);\n\t}...\n}\n\nIci le DomainValidator fait appel à un service web pour vérifier l'existence d'un nom de domaine. Le test unitaire de la méthode CheckDomainExists pose donc problème.\n\nSolution\n\nLa solution consiste à utiliser un bouchon à la place du DomainValidator.\n\nPour cela, un peu de remaniement de code est nécessaire (refactoring) :\n\nl'objet DomainValidator n'est plus instancié dans le constructeur mais injecté par constructeur ou par mutateur (propriété)\nOn utilise une interface à la place de l'objet réel pour \"inverser la dépendance\" de la classe EmailAdressValidator non plus sur la classe \"DomainValidator\" mais sur une interface \"IDomainValidator\"\n\nExemple avec injection par constructeur :\n\n\u002F\u002F Interface IDomainValidator\npublic interface IDomainValidator\n{\n\tbool Exists(string sDomain);\n}\n\n\u002F\u002F Classe à tester\nclass  EmailAddressValidator\n{\n\t\u002F\u002F Interface\n\tprivate readonly IDomainValidator domainValidator;\n\n\tpublic EmailAddressValidator(IDomainValidator domainValidator)\n\t{\n\t\tthis.domainValidator = domainValidator;\n\t}\n\n\tpublic bool CheckEmailAddressSyntax(string emailAddress)\n\t{\n\t\tif(sEmailAddress == null )\n\t\t{\n\t\t\tthrow new NullReferenceException();\n\t\t}\n\t\treturn Regex.IsMatch(emailAddress, @\"^\\[w.-\\]+@\\[a-zA-Z0-9-\\]+(.\\[a-zA-Z0-9-\\]{1,})\\*(.\\[a-zA-Z\\]{2,3}){1,2}$\");\n\t}\n\t...\n\tpublic bool CheckDomainExists(string domain)\n\t{\n\t\treturn  domainValidator.Exists(domain);\n\t}\n\t...\n}\n\nExemple avec injection par mutatteur (propriété getter\u002Fsetter) :\n\n\u002F\u002F Classe à tester\nclass  EmailAddressValidator\n{\n\t\u002F\u002F Interface\n\tpublic IDomainValidator domainValidator { get; set; }\n\n   public EmailAddressValidator()\n   {\n   }\n   ....\n\nA partir de là, il faut écrire une implémentation de IDomainValidator valable uniquement pour le test.\n\nclass FakeDomainValidator : IDomainValidator\n\t{\n\t\tpublic bool Exists(string sDomain)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\nLes tests de EmailAddressValidator pourront donc être indépendants de l'implémentation de IDomainValidator.\n\nLimitations\n\nSi vous souhaitez tester le comportement de EmailAddressValidator dans le cas d'un retour true et false, il faut écrire deux bouchons.\nSi l'objet est complexe et contient plus de 3 méthodes, l'écriture des bouchons est rapidement fastidieuse.\n\nPour cela, il faut utiliser des outils qui génèrent les bouchons dynamiquement. Voir partie suivante sur les mocks.\n\nPrésentation des Mocks\n\nLes Mocks permettent de s'affranchir de l'écriture des bouchons cités plus haut. Deux lignes de code suffisent pour créer une implémentation vide d'une interface :\n\n      var mock = new Mock();\n      IDomainValidator domainValidatorMock = mock.Object;\n\nMocks pour tester l'état des objets\n\nOn peut désormais écrire :\n\nEAV = new EmailAddressValidator ();\nEAV.domainValidator = domainValidatorMock;\nEAV.CheckDomainExists(\"domaine.fr\");\n\nPar défaut, nous n'avons pas défini ce que devait renvoyer Exists de domainValidatorMock, donc la méthode va renvoyer false (la valeur d'un bool par défaut).\n\nIci, on va donc tester la méthode CheckDomainExists de EmailAddressValidator sans faire d'appel à un web service.\n\nPréciser le comportement du mock\n\nDans l'exemple précédent, on va coder deux tests, un ou le résultat du IDomainValidator est false, l'autre ou c'est true. Pour cela, on va initialiser le mock avec la méthode Setup :\n\n        \\[Test\\]\n\t\tpublic void TestDomainExist()\n\t\t{\n\t\t\tEAV = new EmailAddressValidator ();\n\t\t\tEAV.domainValidator = domainValidatorMock;\n\t\t\tmock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(true);\n\t\t\tAssert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n\t\t}\n\n        \\[Test\\]\n\t\tpublic void TestDomainNotExist()\n\t\t{\n\t\t\tEAV = new EmailAddressValidator ();\n\t\t\tEAV.domainValidator = domainValidatorMock;\n\t\t\tmock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(false);\n\t\t\tAssert.IsTrue(EAV.CheckDomainExists(\"domaine.fr\"));\n\t\t}\n\nLa méthode Setup prend une lambda expression indiquant le comportement attendu de la méthode Exists sur l'objet.\n\nOn remarque l'utilisation de It.IsAny() qui indique que l'appel de Exists avec n'importe quel string renverra true.\n\nTout le comportement de la méthode bouchonnée peut être précisé comme cela.\nPar exemple si la méthode doit renvoyer une exception :\n\nmock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(false).Throws(new ArgumentException(\"invalid argument\"));\n\nOn peut indiquer que l'appel de la méthode doit ensuite déclencher une fonction de rappel :\n\nmock.Setup(foo =\u003E foo.Exists(It.IsAny())).Returns(false).Callback(() =\u003E MethodToCall());\n\nMock pour tester le comportement des objets\n\nEn réalité il existe deux types de tests à faire :\n\ntester que EmailAdressValidator se comporte bien\ntester que DomainValidator est correctement appelé par EmailAdressValidator\n\npour le deuxième type de test, le mock peut ajouter des attentes (ou expectations) :\n\n            \u002F\u002F \"Behavior verification\" (vérifications du comportement de l'objet par des attentes)\n\t\t\tmock.Verify(foo =\u003E foo.Exists(It.IsAny())).Returns(false), Times.AtMostOnce(),\n\t\t\t\"Fail message: method IDomainValidator.Existsshould be called and called only once\");\n\nIci par exemple on vérifie que la méthode Exists ne peut être appelé qu'une seule fois.\n",readTime:{text:"8 min read",minutes:7.69,time:461400,words:1538}},relatedArticles:[{slug:"java-vs-c-la-gestion-des-exceptions",description:an,id:"143",title:"Java Vs C# : La gestion des exceptions",date:"2011-03-23",tags:[z,ao],img:ap,cover:aq,path:"\u002Farticles\u002F2011\u002F03\u002F23\u002Fjava-vs-c-la-gestion-des-exceptions"},{slug:"eviter-les-conflits-de-nom-dans-les-interfaces-en-c",description:an,id:"286",title:"Java Vs C# : Eviter les conflits de nom dans les interfaces",date:"2011-03-29",tags:[z,ao],img:ap,cover:"cover7.jpg",path:"\u002Farticles\u002F2011\u002F03\u002F29\u002Feviter-les-conflits-de-nom-dans-les-interfaces-en-c"},{slug:"bonnes-pratique-de-codage-en-c-2",description:"Dans la lignée d'un [billet précédent](http:\u002F\u002Flocalhost\u002Flocalweb\u002Fwordpress\u002F?p=144 \"Introduction aux tests unitaires et aux bouchons en C#\") qui consti...",id:"145",title:"Bonnes pratique de codage en C#",date:I,tags:[z,J],img:"linkext7.gif",cover:aq,path:"\u002Farticles\u002F2010\u002F11\u002F28\u002Fbonnes-pratique-de-codage-en-c-2"}],_img:{"/_ipx/_/hugo-nb.jpg":"\u002F_nuxt\u002Fimage\u002Fc3e54c.jpg"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a","true",-1,"span","icon","icon-link","div","nuxt-content-highlight","pre","language-text","line-numbers","code",2,"h2","strong","li","nofollow","noopener","noreferrer","_blank","Exemple :","csharp","ul","br",3,"em","}","mailto:Nom@entreprise.com","Nom@entreprise.com","h3","2010-11-28","testunitaire","écriture-dun-premier-test","Écriture d'un premier test","différentes-assertions","Différentes assertions","setupteardown","Setup\u002FTearDown","la-couverture-de-code","La couverture de code","test-paramétré","Test paramétré","le-bouchonnage","Le bouchonnage","problématique","Problématique","solution","Solution","limitations","Limitations","mocks-pour-tester-létat-des-objets","Mocks pour tester l'état des objets","préciser-le-comportement-du-mock","Préciser le comportement du mock","mock-pour-tester-le-comportement-des-objets","Mock pour tester le comportement des objets","http:\u002F\u002Fgallio.org\u002Fapi\u002Fhtml\u002FAllMembers_T_MbUnit_Framework_Assert.htm","Assert","http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FCode_source","http:\u002F\u002Fwww.ncover.com\u002F","NCover",") :","2022-05-27T16:08:26.893Z","[![](\u002Fimages\u002Fjavac1.png \"javac\")](http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2011\u002F05\u002Fjavac1.png) **Warning, warning,** ceci n'est pas une rubrique...","java","javac1.png","cover3.jpg")));