__NUXT_JSONP__("/2010/01/28/lets-swing", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E){return {data:[{article:{slug:"lets-swing",description:"Vous connaissez Swing ? Oui, enfin non, pas la [musique](http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FSwing_%28musique%29 \"Musique swing\")... En plus d'avoir fait dan...",id:"141",title:"Let's Swing !",date:"2010-01-28",categories:["waza"],tags:["edt",u,r],img:v,cover:"cover7.jpg",toc:[{id:w,depth:3,text:x}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:a,value:"Vous connaissez Swing ? Oui, enfin non, pas la "},{type:b,tag:e,props:{href:"http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FSwing_%28musique%29",rel:[f,g,h],target:i,title:"Musique swing"},children:[{type:a,value:"musique"}]},{type:a,value:"... En plus d'avoir fait danser des générations, il s'agit aussi de la librairie Java pour les interfaces lourdes en Java (ok c'est moins glamour)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"A propos de Swing on parle souvent de sa grande complexité et le moins que l'on puisse dire, c'est que ce n'est pas exagéré (là on peut voir la comparaison avec la musique en fin de compte). Profitons de cet article pour revenir sur quelques uns de ces aspects qui en ont déjà dérouté plus d'un  :"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"la complexité de la gestion de l'EDT"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"les pièges du modèle événementiel."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Si ces deux points viennent souvent en tête des mauvaises pratiques de programmation les plus courantes, leurs effets sont surtout une des causes de "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.developpez.net\u002Fforums\u002Fd833682-4\u002Fjava\u002Finterfaces-graphiques-java\u002Fon-faire-client-lourd-java\u002F",rel:[f,g,h],target:i,title:"La mauvaise réputation de Swing"},children:[{type:a,value:"la mauvaise réputation"}]},{type:a,value:" de Swing."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Allez, entrons dans le vif du sujet."}]},{type:a,value:c},{type:b,tag:"h3",props:{id:w},children:[{type:b,tag:e,props:{href:"#ledt-et-la-gestion-des-threads",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"L'un des éceuils majeurs sur beaucoup d'IHM Java c'est la gestion des threads. En effet Swing repose sur un thread principal pour la gestion de l'affichage. Je ne décrirais pas dans le détail l'objet de ce Thread mais celui-ci a pour objectif de repeindre les différentes parties affiché dans un certain ordre. Ce thread appelé EDT (Event dispatcher Thread) suit donc un algorithme relativement séquentiel pour l'affichage. Si vous voulez en savoir plus sur l'EDT, je vous conseille la lecture de "},{type:b,tag:e,props:{href:"http:\u002F\u002Ffilthyrichclients.org\u002F",rel:[f,g,h],target:i,title:"Filthy Rich Client"},children:[{type:a,value:"Filthy Rich Clients"}]},{type:a,value:", son fonctionnement y est décrit en détail dans plusieurs chapitres."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ce qu'il faut en retenir, c'est que l'affichage géré par l'EDT n'est pas Thread safe ! Les opérations liées à l'affichage des composants graphiques est monothread et toute mise à jour en dehors de ce thread peut avoir un comportement imprévisible."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ce qui implique :"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"si l'affichage est monothread, il faut placer le traitements longs qui ne sont pas liés à l'affichage dans des threads séparés"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"à l'inverse, pour les modifications des composants graphiques il faut poster toutes les demandes de modifications de l'IHM dans l'EDT"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"sinon vous risquez respectivement :"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"d'avoir une application extrèmement lente puisque les traitements sous-jacents vont ralentir l'affichage"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"d'avoir des erreurs d'affichage puisque les ordres de repaint ne seront pas executés dans le bon sens"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Je vous renvoie à "},{type:b,tag:e,props:{href:"http:\u002F\u002Fgfx.developpez.com\u002Ftutoriel\u002Fjava\u002Fswing\u002Fswing-threading\u002F",rel:[f,g,h],target:i},children:[{type:a,value:"un excellent article de Romain Guy (Gfx)"}]},{type:a,value:", co-auteur de Filthy Rich Client justement,  pour plus de détails."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Soyons clairs, débutants comme confirmés peuvent tomber dans ces pièges. Je vais surtout parler des problèmes d'affichage car bien souvent les problèmes de lenteur sont plus simples à débusquer (ils arrivent à des moments précis du coup on devine \"facilement\" le traitement qui ralentit)."}]},{type:a,value:c},{type:b,tag:s,props:{id:"les-problèmes-daffichage"},children:[{type:b,tag:e,props:{href:"#les-probl%C3%A8mes-daffichage",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Les problèmes d'affichage"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Les problèmes d'affichage peuvent être beaucoup plus pervers. Vous avez les traditionnels écrans gris. Mais vous pouvez aussi avoir des choses plus vicieuses :"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"des doubles affichages de fenêtre fantomes,"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"des textes incomplets,"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"des pertes de focus etc..."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Un problème d'affichage comme je l'indiquais résulte de l'EDT qui tente de raffraichir l'écran et l'ensemble des informations visibles avec des informations que vous lui avez donné de facon incohérente. Par exemple vous avez modifié un tableau hors de l'EDT ou repositionné une fenêtre etc..."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Outre le symptome graphique, vous pouvez rencontrer ce type de trace dans votre application :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Exception in thread \"AWT-EventQueue-0\" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 5\nat java.util.Vector.get(Unknown Source)\nat com.developpez.table.TableSelectionModel.isSelectionEmpty(TableSelectionModel.java:565)\nat javax.swing.DefaultListSelectionModel.clear(Unknown Source)\nat javax.swing.DefaultListSelectionModel.changeSelection(Unknown Source)\nat javax.swing.DefaultListSelectionModel.changeSelection(Unknown Source)\nat javax.swing.DefaultListSelectionModel.setLeadSelectionIndex(Unknown Source)\nat com.developpez.table.TableSelectionModel.clearSelection(TableSelectionModel.java:94)\nat com.developpez.table.MyInputBean.focusGained(MyInputBean.java:99)\nat java.awt.AWTEventMulticaster.focusGained(Unknown Source)\nat java.awt.Component.processFocusEvent(Unknown Source)\nat java.awt.Component.processEvent(Unknown Source)\nat java.awt.Container.processEvent(Unknown Source)\nat java.awt.Component.dispatchEventImpl(Unknown Source)\nat java.awt.Container.dispatchEventImpl(Unknown Source)\nat java.awt.Component.dispatchEvent(Unknown Source)\nat java.awt.KeyboardFocusManager.redispatchEvent(Unknown Source)\nat java.awt.DefaultKeyboardFocusManager.typeAheadAssertions(Unknown Source)\nat java.awt.DefaultKeyboardFocusManager.dispatchEvent(Unknown Source)\nat java.awt.Component.dispatchEventImpl(Unknown Source)\nat java.awt.Container.dispatchEventImpl(Unknown Source)\nat java.awt.Component.dispatchEvent(Unknown Source)\nat java.awt.EventQueue.dispatchEvent(Unknown Source)\nat java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\nat java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\nat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\nat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\nat java.awt.EventDispatchThread.run(Unknown Source)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:y,props:{},children:[{type:a,value:"problème de focus sur une table modifié hors de l'EDT"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"java.lang.ArrayIndexOutOfBoundsException: No such child: 2\nat java.awt.Container.getComponent(Container.java:237)\nat javax.swing.JComponent.rectangleIsObscured(JComponent.java:3702)\nat javax.swing.JComponent.paint(JComponent.java:806)\nat javax.swing.JLayeredPane.paint(JLayeredPane.java:557)\nat javax.swing.JComponent.paintWithOffscreenBuffer(JComponent.java:4787)\nat javax.swing.JComponent.paintDoubleBuffered(JComponent.java:4740)\nat javax.swing.JComponent._paintImmediately(JComponent.java:4685)\nat javax.swing.JComponent.paintImmediately(JComponent.java:4488)\nat javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:410)\nat javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:117)\nat java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:189)\nat java.awt.EventQueue.dispatchEvent(EventQueue.java:478)\nat java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:201)\nat java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:151)\nat java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:145)\nat java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:137)\nat java.awt.EventDispatchThread.run(EventDispatchThread.java:100)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:y,props:{},children:[{type:a,value:"problème de repaint sur des zones modifié hors de l'EDT"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Avec cette stacktrace on se rend compte de la difficulté du problème : ce n'est pas notre code ^^ Donc en debug il y a de grands risques que l'on ne voit rien. C'est vrai qu'avec un peu d'expérience on comprend rapidement qu'on est face à un problème d'EDT mais traquer manuellement le code responsable reste pénible."}]},{type:a,value:c},{type:b,tag:s,props:{id:"les-solutions"},children:[{type:b,tag:e,props:{href:"#les-solutions",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Les solutions"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Heureusement, certains ont pris le temps de réfléchir à cet épineux problème et il existe plusieurs solutions."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Attention, toutes les solutions décrites ci-dessous s'attachent à la détection des bouts de codes fautifs. Une fois le code repéré, c'est à vous de le corriger. Ce ne sont pas des fix magiques qui rendent clean votre code."}]},{type:a,value:c},{type:b,tag:p,props:{id:"swinghelper-swinghelper"},children:[{type:b,tag:e,props:{href:"#swinghelper-swinghelper",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Swinghelper ("},{type:b,tag:e,props:{href:z,rel:[f,g,h],target:i,title:"SwingHelper"},children:[{type:a,value:z}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Au sein du swinglab on retrouve Swinghelper, un projet d'utilitaires qui permet justement de détecter les mises à jour hors de l'EDT via un ThreadCheckingRepaintManager. Ce repaint manager permet de détecter que les ordres de repaint ont été envoyé dans l'EDT, dans le cas contraire on affiche une belle stacktrace qui permet de retrouver le bout de code fautif. Cependant cette méthode a pour défaut qu'elle ne prend pas en compte les appels qui n'envoient pas de repaint (les getters par exemple). C'est déjà une bonne première piste et c'est assez peu intrusif."}]},{type:a,value:c},{type:b,tag:p,props:{id:"substance-substance"},children:[{type:b,tag:e,props:{href:"#substance-substance",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Substance ("},{type:b,tag:e,props:{href:A,rel:[f,g,h],target:i,title:"Substance"},children:[{type:a,value:A}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La c'est un peu plus qu'une solution de détection de la mauvaise utilisation de l'EDT et c'est assez intrusif. Substance est une librairie de look and feel java assez sympa dont j'ai déjà parlé "},{type:b,tag:e,props:{href:"http:\u002F\u002Flocalhost\u002Flocalweb\u002Fwordpress\u002F?p=136",rel:[f,g,h],target:i,title:"Substance, une librairie « hype » pour Swing"},children:[{type:a,value:"dans un précédent billet"}]},{type:a,value:". Et c'est Substance qui rajoute un check de cohérence dans votre application Swing. Si on se réfère à "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.pushing-pixels.org\u002F?p=368",rel:[f,g,h],target:i},children:[{type:a,value:"l'article de l'auteur"}]},{type:a,value:", dès qu'un composant est créé, Substance va faire un check lors de l'appel à createUI. Ca ne prend pas en compte tout les cas de figure (seul les instanciations de composants sont blindés) mais c'est une sécurité supplémentaire pour éviter une mauvaise programmation. Utiliser Substance juste pour cette fonctionnalité serait ridicule, par contre si vous l'avez adopté pour ces look and feel cette fonctionnalité est un bonus appréciable."}]},{type:a,value:c},{type:b,tag:p,props:{id:"les-aspects"},children:[{type:b,tag:e,props:{href:"#les-aspects",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Les aspects"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La "},{type:b,tag:e,props:{href:"http:\u002F\u002Fewawszczyk.developpez.com\u002Ftutoriel\u002Fjava\u002Fspring\u002Faop\u002F",rel:[f,g,h],target:i,title:"Programmation par aspect"},children:[{type:a,value:"programmation par aspect"}]},{type:a,value:" trouve ici une bonne application."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"L'utilisation de l'AOP pour le débuggage Swing a été décrite "},{type:b,tag:e,props:{href:"http:\u002F\u002Fweblogs.java.net\u002Fblog\u002Falexfromsun\u002Farchive\u002F2006\u002F02\u002Fdebugging_swing.html",rel:[f,g,h],target:i,title:"Swing debug"},children:[{type:a,value:"sur l'article suivant"}]},{type:a,value:" en anglais par Alexander Potochkin. L'aspect créé par l'auteur permet ici d'enrober les appels sur les JComponents pour détecter tout appel Swing hors de l'EDT."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Le code de l'aspect :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"import javax.swing.*;"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"aspect EdtRuleChecker\n{\nprivate boolean isStressChecking = true;"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public pointcut anySwingMethods(JComponent c):\ntarget(c) && call(* *(..));"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"public pointcut threadSafeMethods():\ncall(* repaint(..)) ||\ncall(* revalidate()) ||\ncall(* invalidate()) ||\ncall(* getListeners(..)) ||\ncall(* add*Listener(..)) ||\ncall(* remove*Listener(..));"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002Fcalls of any JComponent method, including subclasses\nbefore(JComponent c): anySwingMethods(c) && !threadSafeMethods() &&    !within(EdtRuleChecker)\n{\nif(!SwingUtilities.isEventDispatchThread() && (isStressChecking || c.isShowing()))\n{\nSystem.err.println(thisJoinPoint.getSourceLocation());\nSystem.err.println(thisJoinPoint.getSignature());\nSystem.err.println();\n}\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\u002F\u002Fcalls of any JComponent constructor, including subclasses\nbefore(): call(JComponent+.new(..))\n{\nif (isStressChecking && !SwingUtilities.isEventDispatchThread())\n{\nSystem.err.println(thisJoinPoint.getSourceLocation());\nSystem.err.println(thisJoinPoint.getSignature() +\n\" *constructor*\");\nSystem.err.println();\n}\n}\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Cet aspect permet d'intercepter toutes les méthodes non thread safe pour les afficher. Evidemment il y a un peu plus de mise en place pour l'utiliser. Personnellement j'ai utilisé le "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.eclipse.org\u002Fajdt\u002F",rel:[f,g,h],target:i,title:"Plugin AspectJ pour Eclipse"},children:[{type:a,value:"plugin AspectJ pour eclipse"}]},{type:a,value:" qui m'a permis d'utiliser directement aspectJ au runtime lors d'une séance de debugging eclipse."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Attention, certains pourraient vouloir modifier cet aspect pour directement reposter les évènements dans l'EDT avec "},{type:b,tag:e,props:{href:"http:\u002F\u002Fjava.sun.com\u002Fjavase\u002F6\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FSwingUtilities.html#invokeAndWait%28java.lang.Runnable%29",rel:[f,g,h],target:i,title:"Swing utilities"},children:[{type:a,value:"SwingUtilitiesHelper.invokeAndWait"}]},{type:a,value:". Je le déconseille, ce serait une rustine. Nettoyez plutôt votre code."}]},{type:a,value:c},{type:b,tag:p,props:{id:"conclusion"},children:[{type:b,tag:e,props:{href:"#conclusion",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Voilà, rien de magique mais des méthodes très efficaces qui selon les contextes devraient vraiment vous aider. J'ai personnellement utilisé les aspects sur une appli un peu vieillote sur laquelle j'ai travaillé et sur laquelle la rêgle de l'EDT n'avait jamais été respecté. Sur un code même modeste de 40 000 lignes je ne m'en serais jamais sorti manuellement ^^"}]},{type:a,value:c},{type:b,tag:s,props:{id:"le-modèle-évènementiel"},children:[{type:b,tag:e,props:{href:"#le-mod%C3%A8le-%C3%A9v%C3%A8nementiel",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Le modèle évènementiel"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En Swing on parle souvent de "},{type:b,tag:e,props:{href:"http:\u002F\u002Ffr.wikipedia.org\u002Fwiki\u002FProgrammation_%C3%A9v%C3%A9nementielle",rel:[f,g,h],target:i,title:"Programmation évenementielle"},children:[{type:a,value:"programmation évènementielle"}]},{type:a,value:". Plusieurs types d'évènements peuvent être \"écoutés\" pour déclencher des actions : click sur un bouton, gain de focus, etc...."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans ce type de programmation on utilise souvent le design pattern Observer. Je vous laisse lire l'article suivant si vous ne connaissez pas ce pattern : "},{type:b,tag:e,props:{href:C,rel:[f,g,h],target:i},children:[{type:a,value:C}]},{type:a,value:". Or ce design pattern a un défaut assez commun si on l'utilise mal : les fuites mémoires"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Prenons un exemple simple :"}]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"un observateur O"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"un observé A s'inscrit auprès de O"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"l'observé A n'est plus utilisé pour une raison quelconque"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dans cet exemple, le développeur n'utilisant plus l'objet A va s'attendre à ce que celui-ci soit collecté par le garbage collector. Or il n'en sera jamais rien puisqu'une référence subsiste auprès de O qui continue d'observer A. Il aurait fallu que l'objet A se désinscrivent pour ne plus conserver de références actives."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"(Plus d'info sur le garbage collector "},{type:b,tag:e,props:{href:"http:\u002F\u002Fgfx.developpez.com\u002Ftutoriel\u002Fjava\u002Fgc\u002F",rel:[f,g,h],target:i,title:"Garbage collector"},children:[{type:a,value:"ici"}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ce type de problèmes est rencontré très fréquemment dans les applications Swing. Je l'ai rencontré lors d'une mission ou ce design pattern avait été beaucoup utilisé sans jamais penser à la désinscription des observés. Lors des phases de développement les concepteurs n'avaient pas détecté ce problème. Mais en production, au bout de plusieurs heures d'utilisation l'application a commencé à beaucoup consommé et être très lente, avant de finalement crasher avec un OutOfMemoryError."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ok, mais que faire sur une application existante pour laquelle la recherche de ces mauvaises utilisations va prendre beaucoup de temps et risque de ne pas être triviale ?"}]},{type:a,value:c},{type:b,tag:p,props:{id:"une-solution-utiliser-les-weak-references-"},children:[{type:b,tag:e,props:{href:"#une-solution-utiliser-les-weak-references-",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:"Une solution, utiliser les weak references !"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"La WeakReference va vous permettre de n'intervenir que sur le code des observateurs et donc de centraliser votre correction."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"On peut en trouver une implémentation sur un "},{type:b,tag:e,props:{href:"http:\u002F\u002Fgfx.developpez.com\u002Ftutoriel\u002Fjava\u002Freference-memoire\u002F",rel:[f,g,h],target:i},children:[{type:a,value:"article de Romain Guy sur developpez.com"}]},{type:a,value:"."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Voici un code succinct qui vous permettra de la comprendre :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"protected void fireMessageCalled(MyEvent e)\n{\nint count = listeners.size();\nfor (int i = 0; i \u003C count; i++)\n{\nWeakReference ref = (WeakReference) listeners.elementAt(i);\nfinal myListener listener = (myListener) ref.get();\nif (listener != null)\n{\nlistener.messageCalled(e);\n} else\n{\nlisteners.remove(ref);\n}\n}\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ici l'évènement déclenché appelle la méthode fireMessageCalled. Celui ci parcourt la liste des listeners (les observés) et les notifie. Si un des listener n'est plus référencé, alors sa référence sera nulle car nous avons utilisé des références faibles (WeakReference)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Une autre implémentation pour simplifier le code pourra être d'utiliser une "},{type:b,tag:e,props:{href:"http:\u002F\u002Fjava.sun.com\u002Fj2se\u002F1.5.0\u002Fdocs\u002Fapi\u002Fjava\u002Futil\u002FWeakHashMap.html",rel:[f,g,h],target:i,title:"WeakHashMap"},children:[{type:a,value:"WeakHashMap."}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Cette fois c'est la collection qui va gérer la suppression des éléments qui ne sont plus référencés."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:"strong",props:{},children:[{type:a,value:"Attention"}]},{type:a,value:" cependant, la clé dans la map sera l'observé lui-même. Il faut donc implémenter les méthodes hashcode et equals et faire en sorte que ces méthodes renvoient un résultat qui ne varie pas au cours du temps (immuabilité de la clé). Je vous invite à lire attentivement les petits warnings indiqués dans la JavaDoc de cette classe sur son utilisation."}]},{type:a,value:c},{type:b,tag:p,props:{id:"conclusion-1"},children:[{type:b,tag:e,props:{href:"#conclusion-1",ariaHidden:k,tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Cette méthode ne pourra s'appliquer qu'à votre code et vous évitera d'implémenter des méthodes pour désinscrire les observés. Cependant que cela ne vous donne pas de mauvaises habitudes, ces méthodes existent pour les observateurs de l'API Swing et si elles sont la c'est pas pour la déco !"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Voilà, en espérant que ces petites astuces auront pu vous aider. En me basant sur ce que j'ai vu ce sont deux problèmes qui reviennent souvent, y compris pour des développeurs confirmés alors ne faites pas l'impasse dessus !"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"a+"}]}]},dir:"\u002Farticles\u002F2010\u002F01\u002F28",path:"\u002Farticles\u002F2010\u002F01\u002F28\u002Flets-swing",extension:".md",createdAt:D,updatedAt:D,bodyPlainText:"\nVous connaissez Swing ? Oui, enfin non, pas la musique... En plus d'avoir fait danser des générations, il s'agit aussi de la librairie Java pour les interfaces lourdes en Java (ok c'est moins glamour).\n\nA propos de Swing on parle souvent de sa grande complexité et le moins que l'on puisse dire, c'est que ce n'est pas exagéré (là on peut voir la comparaison avec la musique en fin de compte). Profitons de cet article pour revenir sur quelques uns de ces aspects qui en ont déjà dérouté plus d'un  :\n\nla complexité de la gestion de l'EDT\nles pièges du modèle événementiel.\n\nSi ces deux points viennent souvent en tête des mauvaises pratiques de programmation les plus courantes, leurs effets sont surtout une des causes de la mauvaise réputation de Swing.\n\nAllez, entrons dans le vif du sujet.\n\nl'EDT et la gestion des threads\n\nL'un des éceuils majeurs sur beaucoup d'IHM Java c'est la gestion des threads. En effet Swing repose sur un thread principal pour la gestion de l'affichage. Je ne décrirais pas dans le détail l'objet de ce Thread mais celui-ci a pour objectif de repeindre les différentes parties affiché dans un certain ordre. Ce thread appelé EDT (Event dispatcher Thread) suit donc un algorithme relativement séquentiel pour l'affichage. Si vous voulez en savoir plus sur l'EDT, je vous conseille la lecture de Filthy Rich Clients, son fonctionnement y est décrit en détail dans plusieurs chapitres.\n\nCe qu'il faut en retenir, c'est que l'affichage géré par l'EDT n'est pas Thread safe ! Les opérations liées à l'affichage des composants graphiques est monothread et toute mise à jour en dehors de ce thread peut avoir un comportement imprévisible.\n\nCe qui implique :\n\nsi l'affichage est monothread, il faut placer le traitements longs qui ne sont pas liés à l'affichage dans des threads séparés\nà l'inverse, pour les modifications des composants graphiques il faut poster toutes les demandes de modifications de l'IHM dans l'EDT\n\nsinon vous risquez respectivement :\n\nd'avoir une application extrèmement lente puisque les traitements sous-jacents vont ralentir l'affichage\nd'avoir des erreurs d'affichage puisque les ordres de repaint ne seront pas executés dans le bon sens\n\nJe vous renvoie à un excellent article de Romain Guy (Gfx), co-auteur de Filthy Rich Client justement,  pour plus de détails.\n\nSoyons clairs, débutants comme confirmés peuvent tomber dans ces pièges. Je vais surtout parler des problèmes d'affichage car bien souvent les problèmes de lenteur sont plus simples à débusquer (ils arrivent à des moments précis du coup on devine \"facilement\" le traitement qui ralentit).\n\nLes problèmes d'affichage\n\nLes problèmes d'affichage peuvent être beaucoup plus pervers. Vous avez les traditionnels écrans gris. Mais vous pouvez aussi avoir des choses plus vicieuses :\n\ndes doubles affichages de fenêtre fantomes,\ndes textes incomplets,\ndes pertes de focus etc...\n\nUn problème d'affichage comme je l'indiquais résulte de l'EDT qui tente de raffraichir l'écran et l'ensemble des informations visibles avec des informations que vous lui avez donné de facon incohérente. Par exemple vous avez modifié un tableau hors de l'EDT ou repositionné une fenêtre etc...\n\nOutre le symptome graphique, vous pouvez rencontrer ce type de trace dans votre application :\n\nException in thread \"AWT-EventQueue-0\" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 5\n at java.util.Vector.get(Unknown Source)\n at com.developpez.table.TableSelectionModel.isSelectionEmpty(TableSelectionModel.java:565)\n at javax.swing.DefaultListSelectionModel.clear(Unknown Source)\n at javax.swing.DefaultListSelectionModel.changeSelection(Unknown Source)\n at javax.swing.DefaultListSelectionModel.changeSelection(Unknown Source)\n at javax.swing.DefaultListSelectionModel.setLeadSelectionIndex(Unknown Source)\n at com.developpez.table.TableSelectionModel.clearSelection(TableSelectionModel.java:94)\n at com.developpez.table.MyInputBean.focusGained(MyInputBean.java:99)\n at java.awt.AWTEventMulticaster.focusGained(Unknown Source)\n at java.awt.Component.processFocusEvent(Unknown Source)\n at java.awt.Component.processEvent(Unknown Source)\n at java.awt.Container.processEvent(Unknown Source)\n at java.awt.Component.dispatchEventImpl(Unknown Source)\n at java.awt.Container.dispatchEventImpl(Unknown Source)\n at java.awt.Component.dispatchEvent(Unknown Source)\n at java.awt.KeyboardFocusManager.redispatchEvent(Unknown Source)\n at java.awt.DefaultKeyboardFocusManager.typeAheadAssertions(Unknown Source)\n at java.awt.DefaultKeyboardFocusManager.dispatchEvent(Unknown Source)\n at java.awt.Component.dispatchEventImpl(Unknown Source)\n at java.awt.Container.dispatchEventImpl(Unknown Source)\n at java.awt.Component.dispatchEvent(Unknown Source)\n at java.awt.EventQueue.dispatchEvent(Unknown Source)\n at java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\n at java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\n at java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n at java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n at java.awt.EventDispatchThread.run(Unknown Source)\n\nproblème de focus sur une table modifié hors de l'EDT\n\n java.lang.ArrayIndexOutOfBoundsException: No such child: 2\n at java.awt.Container.getComponent(Container.java:237)\n at javax.swing.JComponent.rectangleIsObscured(JComponent.java:3702)\n at javax.swing.JComponent.paint(JComponent.java:806)\n at javax.swing.JLayeredPane.paint(JLayeredPane.java:557)\n at javax.swing.JComponent.paintWithOffscreenBuffer(JComponent.java:4787)\n at javax.swing.JComponent.paintDoubleBuffered(JComponent.java:4740)\n at javax.swing.JComponent.\\_paintImmediately(JComponent.java:4685)\n at javax.swing.JComponent.paintImmediately(JComponent.java:4488)\n at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:410)\n at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:117)\n at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:189)\n at java.awt.EventQueue.dispatchEvent(EventQueue.java:478)\n at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:201)\n at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:151)\n at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:145)\n at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:137)\n at java.awt.EventDispatchThread.run(EventDispatchThread.java:100)\n\nproblème de repaint sur des zones modifié hors de l'EDT\n\nAvec cette stacktrace on se rend compte de la difficulté du problème : ce n'est pas notre code ^^ Donc en debug il y a de grands risques que l'on ne voit rien. C'est vrai qu'avec un peu d'expérience on comprend rapidement qu'on est face à un problème d'EDT mais traquer manuellement le code responsable reste pénible.\n\nLes solutions\n\nHeureusement, certains ont pris le temps de réfléchir à cet épineux problème et il existe plusieurs solutions.\n\nAttention, toutes les solutions décrites ci-dessous s'attachent à la détection des bouts de codes fautifs. Une fois le code repéré, c'est à vous de le corriger. Ce ne sont pas des fix magiques qui rendent clean votre code.\n\nSwinghelper (https:\u002F\u002Fswinghelper.dev.java.net\u002F)\n\nAu sein du swinglab on retrouve Swinghelper, un projet d'utilitaires qui permet justement de détecter les mises à jour hors de l'EDT via un ThreadCheckingRepaintManager. Ce repaint manager permet de détecter que les ordres de repaint ont été envoyé dans l'EDT, dans le cas contraire on affiche une belle stacktrace qui permet de retrouver le bout de code fautif. Cependant cette méthode a pour défaut qu'elle ne prend pas en compte les appels qui n'envoient pas de repaint (les getters par exemple). C'est déjà une bonne première piste et c'est assez peu intrusif.\n\nSubstance (https:\u002F\u002Fsubstance.dev.java.net\u002F)\n\nLa c'est un peu plus qu'une solution de détection de la mauvaise utilisation de l'EDT et c'est assez intrusif. Substance est une librairie de look and feel java assez sympa dont j'ai déjà parlé dans un précédent billet. Et c'est Substance qui rajoute un check de cohérence dans votre application Swing. Si on se réfère à l'article de l'auteur, dès qu'un composant est créé, Substance va faire un check lors de l'appel à createUI. Ca ne prend pas en compte tout les cas de figure (seul les instanciations de composants sont blindés) mais c'est une sécurité supplémentaire pour éviter une mauvaise programmation. Utiliser Substance juste pour cette fonctionnalité serait ridicule, par contre si vous l'avez adopté pour ces look and feel cette fonctionnalité est un bonus appréciable.\n\nLes aspects\n\nLa programmation par aspect trouve ici une bonne application.\n\nL'utilisation de l'AOP pour le débuggage Swing a été décrite sur l'article suivant en anglais par Alexander Potochkin. L'aspect créé par l'auteur permet ici d'enrober les appels sur les JComponents pour détecter tout appel Swing hors de l'EDT.\n\nLe code de l'aspect :\n\nimport javax.swing.\\*;\n\naspect EdtRuleChecker\n{\n private boolean isStressChecking = true;\n\n public pointcut anySwingMethods(JComponent c):\n target(c) && call(\\* \\*(..));\n\n public pointcut threadSafeMethods():\n call(\\* repaint(..)) ||\n call(\\* revalidate()) ||\n call(\\* invalidate()) ||\n call(\\* getListeners(..)) ||\n call(\\* add\\*Listener(..)) ||\n call(\\* remove\\*Listener(..));\n\n \u002F\u002Fcalls of any JComponent method, including subclasses\n before(JComponent c): anySwingMethods(c) && !threadSafeMethods() &&    !within(EdtRuleChecker)\n {\n if(!SwingUtilities.isEventDispatchThread() && (isStressChecking || c.isShowing()))\n {\n System.err.println(thisJoinPoint.getSourceLocation());\n System.err.println(thisJoinPoint.getSignature());\n System.err.println();\n }\n }\n\n \u002F\u002Fcalls of any JComponent constructor, including subclasses\n before(): call(JComponent+.new(..))\n {\n if (isStressChecking && !SwingUtilities.isEventDispatchThread())\n {\n System.err.println(thisJoinPoint.getSourceLocation());\n System.err.println(thisJoinPoint.getSignature() +\n \" \\constructor\\\");\n System.err.println();\n }\n }\n}\n\nCet aspect permet d'intercepter toutes les méthodes non thread safe pour les afficher. Evidemment il y a un peu plus de mise en place pour l'utiliser. Personnellement j'ai utilisé le plugin AspectJ pour eclipse qui m'a permis d'utiliser directement aspectJ au runtime lors d'une séance de debugging eclipse.\n\nAttention, certains pourraient vouloir modifier cet aspect pour directement reposter les évènements dans l'EDT avec SwingUtilitiesHelper.invokeAndWait. Je le déconseille, ce serait une rustine. Nettoyez plutôt votre code.\n\nConclusion\n\nVoilà, rien de magique mais des méthodes très efficaces qui selon les contextes devraient vraiment vous aider. J'ai personnellement utilisé les aspects sur une appli un peu vieillote sur laquelle j'ai travaillé et sur laquelle la rêgle de l'EDT n'avait jamais été respecté. Sur un code même modeste de 40 000 lignes je ne m'en serais jamais sorti manuellement ^^\n\nLe modèle évènementiel\n\nEn Swing on parle souvent de programmation évènementielle. Plusieurs types d'évènements peuvent être \"écoutés\" pour déclencher des actions : click sur un bouton, gain de focus, etc....\n\nDans ce type de programmation on utilise souvent le design pattern Observer. Je vous laisse lire l'article suivant si vous ne connaissez pas ce pattern : http:\u002F\u002Fwww.design-patterns.fr\u002FObservateur.html. Or ce design pattern a un défaut assez commun si on l'utilise mal : les fuites mémoires\n\nPrenons un exemple simple :\n\nun observateur O\nun observé A s'inscrit auprès de O\nl'observé A n'est plus utilisé pour une raison quelconque\n\nDans cet exemple, le développeur n'utilisant plus l'objet A va s'attendre à ce que celui-ci soit collecté par le garbage collector. Or il n'en sera jamais rien puisqu'une référence subsiste auprès de O qui continue d'observer A. Il aurait fallu que l'objet A se désinscrivent pour ne plus conserver de références actives.\n\n(Plus d'info sur le garbage collector ici)\n\nCe type de problèmes est rencontré très fréquemment dans les applications Swing. Je l'ai rencontré lors d'une mission ou ce design pattern avait été beaucoup utilisé sans jamais penser à la désinscription des observés. Lors des phases de développement les concepteurs n'avaient pas détecté ce problème. Mais en production, au bout de plusieurs heures d'utilisation l'application a commencé à beaucoup consommé et être très lente, avant de finalement crasher avec un OutOfMemoryError.\n\nOk, mais que faire sur une application existante pour laquelle la recherche de ces mauvaises utilisations va prendre beaucoup de temps et risque de ne pas être triviale ?\n\nUne solution, utiliser les weak references !\n\nLa WeakReference va vous permettre de n'intervenir que sur le code des observateurs et donc de centraliser votre correction.\n\nOn peut en trouver une implémentation sur un article de Romain Guy sur developpez.com.\n\nVoici un code succinct qui vous permettra de la comprendre :\n\nprotected void fireMessageCalled(MyEvent e)\n{\n\tint count = listeners.size();\n\tfor (int i = 0; i \u003C count; i++)\n\t{\n\t\tWeakReference ref = (WeakReference) listeners.elementAt(i);\n\t\tfinal myListener listener = (myListener) ref.get();\n\t\tif (listener != null)\n\t\t{\n\t\t\tlistener.messageCalled(e);\n\t\t} else\n\t\t{\n\t\t\tlisteners.remove(ref);\n\t\t}\n\t}\n}\n\nIci l'évènement déclenché appelle la méthode fireMessageCalled. Celui ci parcourt la liste des listeners (les observés) et les notifie. Si un des listener n'est plus référencé, alors sa référence sera nulle car nous avons utilisé des références faibles (WeakReference).\n\nUne autre implémentation pour simplifier le code pourra être d'utiliser une WeakHashMap.\n\nCette fois c'est la collection qui va gérer la suppression des éléments qui ne sont plus référencés.\n\nAttention cependant, la clé dans la map sera l'observé lui-même. Il faut donc implémenter les méthodes hashcode et equals et faire en sorte que ces méthodes renvoient un résultat qui ne varie pas au cours du temps (immuabilité de la clé). Je vous invite à lire attentivement les petits warnings indiqués dans la JavaDoc de cette classe sur son utilisation.\n\nConclusion\n\nCette méthode ne pourra s'appliquer qu'à votre code et vous évitera d'implémenter des méthodes pour désinscrire les observés. Cependant que cela ne vous donne pas de mauvaises habitudes, ces méthodes existent pour les observateurs de l'API Swing et si elles sont la c'est pas pour la déco !\n\nVoilà, en espérant que ces petites astuces auront pu vous aider. En me basant sur ce que j'ai vu ce sont deux problèmes qui reviennent souvent, y compris pour des développeurs confirmés alors ne faites pas l'impasse dessus !\n\na+\n",readTime:{text:"10 min read",minutes:9.57,time:574200,words:1914}},relatedArticles:[{slug:"swing-or-not-swing-that-is-the-question",description:"## Peut-on faire un client lourd en Java ?\nAyant bossé en Java je me suis heurté à Swing comme on peut se heurter à un mur. Ouch, quand on vient du W...",id:"135",title:"Swing or not Swing, that is the question",date:"2009-10-30",tags:[E,r],img:v,cover:"cover2.jpg",path:"\u002Farticles\u002F2009\u002F10\u002F30\u002Fswing-or-not-swing-that-is-the-question"},{slug:"substance-une-librairie-hype-pour-swing",description:"Mon [dernier billet sur Swing](index.php\u002Fthe-news\u002F51-swing-or-not-swing \"Swing or not swing\") pouvait paraître pessimiste puisque je parlais de cette ...",id:"136",title:"Substance, une librairie \"hype\" pour Swing",date:"2009-11-05",tags:[E,u,r],img:"button.png",cover:"cover4.jpg",path:"\u002Farticles\u002F2009\u002F11\u002F05\u002Fsubstance-une-librairie-hype-pour-swing"}],_img:{"/_ipx/_/hugo-nb.jpg":"\u002F_nuxt\u002Fimage\u002Fc3e54c.jpg"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a","nofollow","noopener","noreferrer","_blank","li","true",-1,"span","icon","icon-link","h5","ul","swing","h4",")","substance","","ledt-et-la-gestion-des-threads","l'EDT et la gestion des threads","em","https:\u002F\u002Fswinghelper.dev.java.net\u002F","https:\u002F\u002Fsubstance.dev.java.net\u002F","Conclusion","http:\u002F\u002Fwww.design-patterns.fr\u002FObservateur.html","2022-05-20T21:03:21.500Z","java")));