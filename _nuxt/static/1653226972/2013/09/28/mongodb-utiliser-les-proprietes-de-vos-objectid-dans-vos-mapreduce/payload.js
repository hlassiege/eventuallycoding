__NUXT_JSONP__("/2013/09/28/mongodb-utiliser-les-proprietes-de-vos-objectid-dans-vos-mapreduce", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H){return {data:[{article:{slug:"mongodb-utiliser-les-proprietes-de-vos-objectid-dans-vos-mapreduce",description:"Je vous propose de voir deux fonctionnalités plutôt pratiques de [MongoDB](http:\u002F\u002Fwww.mongodb.org\u002F) dans ce billet. D’une part je vais vous parler de ...",id:"970",title:"MongoDB : Utiliser les propriétés de vos ObjectId dans vos MapReduce",date:"2013-09-28",categories:["waza"],tags:[j,k],img:"objectid.png",cover:"cover7.jpg",toc:[{id:s,depth:t,text:r},{id:j,depth:t,text:u},{id:v,depth:w,text:x},{id:y,depth:w,text:z}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:a,value:"Je vous propose de voir deux fonctionnalités plutôt pratiques de "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.mongodb.org\u002F",rel:[f,g,h],target:i},children:[{type:a,value:"MongoDB"}]},{type:a,value:" dans ce billet. D’une part je vais vous parler de certaines propriétés très intéressantes des "},{type:b,tag:e,props:{href:"http:\u002F\u002Fdocs.mongodb.org\u002Fmanual\u002Freference\u002Fobject-id\u002F",rel:[f,g,h],target:i},children:[{type:a,value:r}]},{type:a,value:", la classe qu’utilise MongoDB pour générer les identifiants de vos entités, et ensuite je vais vous montrer comment utiliser cette propriété dans un exemple tout simple avec un MapReduce."}]},{type:a,value:c},{type:b,tag:A,props:{id:s},children:[{type:b,tag:e,props:{href:"#objectid",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:r}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"MongoDB est une base de données orientée documents dans laquelle vous pouvez stocker des documents Json dans des collections, elles-mêmes regroupées dans des bases de données."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Chaque document Json doit contenir une propriété _id qui identifie de manière unique votre document au sein de votre collection."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Par exemple :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"{\n\"_id\" : 1\n… autre propriétés\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Par défaut, MongoDB vous propose de générer lui-même des identifiants grâce aux ObjectId :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"{"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"\"_id\" : ObjectId(\"5197c6b453cce2ec3a743811\")\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Comme MongoDB privilégie avant tout la scalabilité, ces identifiants ne sont pas générés par un processus centralisé. Évidemment quand vous les laissez générer côté serveur, l’intérêt reste limité puisque vous n’avez qu’un seul maître actif. Mais ces ObjectId peuvent être générés côté client (et certains drivers marchent de cette façon)."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ces identifiants doivent donc être “à priori uniques” sans avoir besoin d’un mécanisme complexe de synchronisation avec le serveur."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour cela MongoDB utilise les ObjectId qui contiennent un identifiant sur 12 bytes."}]},{type:a,value:c},{type:b,tag:"ul",props:{},children:[{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:"4 bytes qui représentent le timestamp courant (nombre de secondes depuis epoch)"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:"3 bytes pour identifier la machine"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:"2 bytes pour représenter l’identifiant du processus"}]},{type:a,value:c},{type:b,tag:q,props:{},children:[{type:a,value:"3 bytes qui représentent un compteur qui démarre à un numéro aléatoire"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:B,props:{alt:"",src:"\u002Fimages\u002Fobjectid.png"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Cet ObjectId a donc une propriété très intéressante, il contient automatiquement la date de création de votre entité !"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ce qui nous permet d’écrire le code suivant par exemple sur le MongoShell :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"var id = ObjectId()\nprint(id)\nObjectId(\"5247019073ed0c203c79b995\")\nprint(id.getTimestamp())\nISODate(\"2013-09-28T16:19:28Z\")"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et si nous utilisions cette propriété pour obtenir quelques statistiques ?"}]},{type:a,value:c},{type:b,tag:A,props:{id:j},children:[{type:b,tag:e,props:{href:"#mapreduce",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Les algorithmes de MapReduce permettent de traiter des données en découpant votre problème initial en plusieurs sous-problèmes."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"L’idée étant d’appliquer la même fonction a des sous ensembles de votre jeu de donnée initial (via une fonction map), puis d’appliquer une “réduction” de ces résultats pour les agréger et trouver le résultat final."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{href:"http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2013\u002F09\u002Ffcd2c-mapreduce.png",rel:[f,g,h],target:i},children:[{type:b,tag:B,props:{alt:j,src:"\u002Fimages\u002Ffcd2c-mapreduce.png"},children:[]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ce type d’algorithme est géré nativement par MongoDB."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour cela vous devez définir une fonction map qui va émettre des couplés clés-valeurs."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Une fonction reduce qui va s’occuper de l'agrégation et ensuite vous appliquez une commande MapReduce sur l’ensemble."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ici, par exemple si on veut compter le nombre d’éléments dans votre collection"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:"em",props:{},children:[{type:a,value:"(l’exemple est volontairement simpliste et n’a aucun intérêt puisque vous pouvez utiliser db.mycollection.count() pour le même résultat)"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"map = function() {\nemit(1,1);\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"reduce = function(key, values) {\nreturn  Array.sum(values);\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"db.mycollection.mapReduce( map , reduce , { out : “results” } )\n{\n\"result\" : \"results\",\n\"timeMillis\" : 751,\n\"counts\" : {\n\"input\" : 113,\n\"emit\" : 113,\n\"reduce\" : 2,\n\"output\" : 1\n},\n\"ok\" : 1,\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Le résultat de ce MapReduce est désormais consultable dans la collection results et sans surprise nous n’avons qu’une seule ligne qui contient notre somme :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"db.results_tst.find()\n{ \"_id\" : 1, \"value\" : 113 }"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Bon, maintenant faisons quelque chose de plus intéressant et utilisons les ObjectId que nous avons vu au dessus."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Imaginons que vous avez un site qui contient une liste d’inscrits et que l’on vous demande le nombre d’inscription par mois."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Votre inscrit très basiquement :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"{\n\"_id\" : ObjectId(\"5197c6b453cce2ec3a743811\"),\n“firstname” : “Hugo”,\n“lastname” : “Lassiege”\n}"}]},{type:a,value:c},{type:b,tag:C,props:{id:v},children:[{type:b,tag:e,props:{href:"#comment-nous-laurions-r%C3%A9solu-en-sql-",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"En SQL, vous auriez du ajouter une colonne figurant la date de création de chaque compte :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"ID = 1\nfirstname = Hugo\nlastname = Lassiege\ncreated = une date (exemple: 26 septembre 2013)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ensuite vous auriez appliqué une requête ressemblant à ceci :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"SELECT COUNT(ID)\nFROM accounts\nGROUP BY YEAR(created), MONTH(created)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Afin d’éviter de faire cette requête sans arrêt nous l’aurions placé dans une vue afin de profiter d’un minimum de cache (et simplifier le requètage) :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CREATE VIEW results as SELECT COUNT(ID)\nFROM accounts\nGROUP BY YEAR(created), MONTH(created)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Certaines bases proposent d’utiliser des vues matérialisées qui ne se rafraîchissent qu’à intervalle régulier vous évitant de relancer constamment le même calcul pour rien."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"(A noter que Mysql ne le supporte pas)"}]},{type:a,value:c},{type:b,tag:C,props:{id:y},children:[{type:b,tag:e,props:{href:"#comment-nous-pouvons-le-r%C3%A9soudre-avec-mongodb",ariaHidden:l,tabIndex:m},children:[{type:b,tag:n,props:{className:[o,p]},children:[]}]},{type:a,value:z}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Déjà partons du principe que vous n'aviez pas pensé à ajouter le champ created, grâce aux ObjectId vous pourriez quand même vous en sortir :)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Tout d’abord nous allons créer une fonction map qui va émettre des clés qui contiendront l’année et le mois de chaque record. Nous allons utiliser la méthode getTimestamp() de ObjectId qui nous renvoie une date."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Il faut voir cette fonction comme l’équivalent du GROUP BY YEAR(created), MONTH(created) fait précédemment :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"map = function() {\nvar key = {   y : this._id.getTimestamp().getFullYear(),"},{type:b,tag:D,props:{},children:[]},{type:a,value:"\nm : this._id.getTimestamp().getMonth()+1   };"},{type:b,tag:D,props:{},children:[]},{type:a,value:"\nemit(key,1);\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ensuite la fonction reduce qui se contentent de faire une somme, l’équivalent de notre SELECT count(ID) :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"reduce = function(key, values) {\nreturn Array.sum(values);\n}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et enfin l’application de la commande :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"db.accounts.mapReduce( map , reduce , { out : “account_stats” } )\ndb.account_stats.find()\n{ \"_id\" : { \"year\" : 2013, \"month\" : 5 }, \"value\" : 200 }\n{ \"_id\" : { \"year\" : 2013, \"month\" : 6 }, \"value\" : 145 }\n{ \"_id\" : { \"year\" : 2013, \"month\" : 7 }, \"value\" : 32 }\n{ \"_id\" : { \"year\" : 2013, \"month\" : 8 }, \"value\" : 45 }\n{ \"_id\" : { \"year\" : 2013, \"month\" : 9 }, \"value\" : 320 }"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Vous remarquerez que nous n’avons pas besoin de relancer le calcul à chaque nouvelle demande puisque la collection de sortie est désormais consultable très facilement."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Maintenant optimisons un peu cela."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"On remarque très rapidement que recalculer systématiquement pour les mois passés n’a aucun sens puisque ces données ne peuvent plus changer. Nous allons donc utiliser un MapReduce incrémental."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Pour cela, il vous suffit d’appliquer deux options supplémentaires à votre commande :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"db.accounts.mapReduce( map , reduce , {\nout : { merge: \"account_stats\" },\nquery : { _id: { $gt: objectIdWithTimestamp(2013\u002F09\u002F01') } },\n} )"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ici nous avons utilisé deux astuces."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Par défaut, le résultat d’un map reduce remplace toutes les données présentes dans la collection de sortie."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Mais nous pouvons préciser le paramètre "},{type:b,tag:E,props:{},children:[{type:a,value:"merge"}]},{type:a,value:" pour que les résultats soient fusionnés avec des résultats déjà présents."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Cela va nous permettre de n’ajouter que les résultats concernant les derniers mois."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et nous allons utiliser le paramètre "},{type:b,tag:E,props:{},children:[{type:a,value:"query"}]},{type:a,value:" pour limiter le jeu de données sur lequel appliquer l’algorithme."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ici nous utilisons une méthode que vous devez définir au préalable permettant de créer un ObjectId à partir d’une date :"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"function objectIdWithTimestamp(timestamp)\n{\n\u002F\u002F Convert string date to Date object (otherwise assume timestamp is a date)\nif (typeof(timestamp) == 'string') {\ntimestamp = new Date(timestamp);\n}"}]},{type:a,value:c},{type:b,tag:"div",props:{className:["nuxt-content-highlight"]},children:[{type:b,tag:"pre",props:{className:["language-text","line-numbers"]},children:[{type:b,tag:"code",props:{},children:[{type:a,value:"\u002F\u002F Convert date object to hex seconds since Unix epoch\nvar hexSeconds = Math.floor(timestamp\u002F1000).toString(16);\n\n\u002F\u002F Create an ObjectId with that hex timestamp\nvar constructedObjectId = ObjectId(hexSeconds + \"0000000000000000\");\n\nreturn constructedObjectId\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"}"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"(source : "},{type:b,tag:e,props:{href:F,rel:[f,g,h],target:i},children:[{type:a,value:F}]},{type:a,value:")"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et voila, vous avez désormais un mapreduce incrémental. On remarquera quand même que l'utilisation d'une date aurait malgré tout simplifié l'écriture de la query de filtrage mais nous nous en sommes sortis sans champ \"created\"."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Et c’est terminé. Nous aurions pu voir encore de multiples choses, comment lancer un MapReduce en Java ou comment faire la même chose avec le framework d’aggrégation de MongoDB. Peut-être une autre fois."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Ou bien vous pouvez aussi me contacter pour "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.lateral-thoughts.com\u002Fformations\u002Fformation-mongodb",rel:[f,g,h],target:i},children:[{type:a,value:"une formation sur MongoDB"}]},{type:a,value:" si jamais ça vous intéresse ;)"}]}]},dir:"\u002Farticles\u002F2013\u002F09\u002F28",path:"\u002Farticles\u002F2013\u002F09\u002F28\u002Fmongodb-utiliser-les-proprietes-de-vos-objectid-dans-vos-mapreduce",extension:".md",createdAt:G,updatedAt:G,bodyPlainText:"\nJe vous propose de voir deux fonctionnalités plutôt pratiques de MongoDB dans ce billet. D’une part je vais vous parler de certaines propriétés très intéressantes des ObjectId, la classe qu’utilise MongoDB pour générer les identifiants de vos entités, et ensuite je vais vous montrer comment utiliser cette propriété dans un exemple tout simple avec un MapReduce.\n\nObjectId\n\nMongoDB est une base de données orientée documents dans laquelle vous pouvez stocker des documents Json dans des collections, elles-mêmes regroupées dans des bases de données.\n\nChaque document Json doit contenir une propriété \\_id qui identifie de manière unique votre document au sein de votre collection.\n\nPar exemple :\n\n{\n\"\\_id\" : 1\n… autre propriétés\n}\n\nPar défaut, MongoDB vous propose de générer lui-même des identifiants grâce aux ObjectId :\n\n{\n\n \"\\_id\" : ObjectId(\"5197c6b453cce2ec3a743811\")\n}\n\nComme MongoDB privilégie avant tout la scalabilité, ces identifiants ne sont pas générés par un processus centralisé. Évidemment quand vous les laissez générer côté serveur, l’intérêt reste limité puisque vous n’avez qu’un seul maître actif. Mais ces ObjectId peuvent être générés côté client (et certains drivers marchent de cette façon).\n\nCes identifiants doivent donc être “à priori uniques” sans avoir besoin d’un mécanisme complexe de synchronisation avec le serveur.\n\nPour cela MongoDB utilise les ObjectId qui contiennent un identifiant sur 12 bytes.\n\n4 bytes qui représentent le timestamp courant (nombre de secondes depuis epoch)\n3 bytes pour identifier la machine\n2 bytes pour représenter l’identifiant du processus\n3 bytes qui représentent un compteur qui démarre à un numéro aléatoire\n\n\n\nCet ObjectId a donc une propriété très intéressante, il contient automatiquement la date de création de votre entité !\n\nCe qui nous permet d’écrire le code suivant par exemple sur le MongoShell :\n\nvar id = ObjectId()\nprint(id)\nObjectId(\"5247019073ed0c203c79b995\")\nprint(id.getTimestamp())\nISODate(\"2013-09-28T16:19:28Z\")\n\nEt si nous utilisions cette propriété pour obtenir quelques statistiques ?\n\nMapReduce\n\nLes algorithmes de MapReduce permettent de traiter des données en découpant votre problème initial en plusieurs sous-problèmes.\n\nL’idée étant d’appliquer la même fonction a des sous ensembles de votre jeu de donnée initial (via une fonction map), puis d’appliquer une “réduction” de ces résultats pour les agréger et trouver le résultat final.\n\nmapreduce\n\nCe type d’algorithme est géré nativement par MongoDB.\n\nPour cela vous devez définir une fonction map qui va émettre des couplés clés-valeurs.\n\nUne fonction reduce qui va s’occuper de l'agrégation et ensuite vous appliquez une commande MapReduce sur l’ensemble.\n\nIci, par exemple si on veut compter le nombre d’éléments dans votre collection\n\n(l’exemple est volontairement simpliste et n’a aucun intérêt puisque vous pouvez utiliser db.mycollection.count() pour le même résultat)\n\nmap = function() {\n\temit(1,1);\n}\n\nreduce = function(key, values) {\n\treturn  Array.sum(values);\n}\n\ndb.mycollection.mapReduce( map , reduce , { out : “results” } )\n{\n        \"result\" : \"results\",\n        \"timeMillis\" : 751,\n        \"counts\" : {\n                \"input\" : 113,\n                \"emit\" : 113,\n                \"reduce\" : 2,\n                \"output\" : 1\n        },\n        \"ok\" : 1,\n}\n\nLe résultat de ce MapReduce est désormais consultable dans la collection results et sans surprise nous n’avons qu’une seule ligne qui contient notre somme :\n\ndb.results\\_tst.find()\n{ \"\\_id\" : 1, \"value\" : 113 }\n\nBon, maintenant faisons quelque chose de plus intéressant et utilisons les ObjectId que nous avons vu au dessus.\n\nImaginons que vous avez un site qui contient une liste d’inscrits et que l’on vous demande le nombre d’inscription par mois.\n\nVotre inscrit très basiquement :\n\n{\n \"\\_id\" : ObjectId(\"5197c6b453cce2ec3a743811\"),\n“firstname” : “Hugo”,\n“lastname” : “Lassiege”\n}\n\nComment nous l’aurions résolu en SQL :\n\nEn SQL, vous auriez du ajouter une colonne figurant la date de création de chaque compte :\n\nID = 1\nfirstname = Hugo\nlastname = Lassiege\ncreated = une date (exemple: 26 septembre 2013)\n\nEnsuite vous auriez appliqué une requête ressemblant à ceci :\n\nSELECT COUNT(ID)\nFROM accounts\nGROUP BY YEAR(created), MONTH(created)\n\nAfin d’éviter de faire cette requête sans arrêt nous l’aurions placé dans une vue afin de profiter d’un minimum de cache (et simplifier le requètage) :\n\nCREATE VIEW results as SELECT COUNT(ID)\nFROM accounts\nGROUP BY YEAR(created), MONTH(created)\n\nCertaines bases proposent d’utiliser des vues matérialisées qui ne se rafraîchissent qu’à intervalle régulier vous évitant de relancer constamment le même calcul pour rien.\n\n(A noter que Mysql ne le supporte pas)\n\nComment nous pouvons le résoudre avec MongoDB\n\nDéjà partons du principe que vous n'aviez pas pensé à ajouter le champ created, grâce aux ObjectId vous pourriez quand même vous en sortir :)\n\nTout d’abord nous allons créer une fonction map qui va émettre des clés qui contiendront l’année et le mois de chaque record. Nous allons utiliser la méthode getTimestamp() de ObjectId qui nous renvoie une date.\n\nIl faut voir cette fonction comme l’équivalent du GROUP BY YEAR(created), MONTH(created) fait précédemment :\n\nmap = function() {\nvar key = {   y : this.\\_id.getTimestamp().getFullYear(),\n         m : this.\\_id.getTimestamp().getMonth()+1   };\nemit(key,1);\n}\n\nEnsuite la fonction reduce qui se contentent de faire une somme, l’équivalent de notre SELECT count(ID) :\n\nreduce = function(key, values) {\nreturn Array.sum(values);\n}\n\nEt enfin l’application de la commande :\n\ndb.accounts.mapReduce( map , reduce , { out : “account\\_stats” } )\ndb.account\\_stats.find()\n{ \"\\_id\" : { \"year\" : 2013, \"month\" : 5 }, \"value\" : 200 }\n{ \"\\_id\" : { \"year\" : 2013, \"month\" : 6 }, \"value\" : 145 }\n{ \"\\_id\" : { \"year\" : 2013, \"month\" : 7 }, \"value\" : 32 }\n{ \"\\_id\" : { \"year\" : 2013, \"month\" : 8 }, \"value\" : 45 }\n{ \"\\_id\" : { \"year\" : 2013, \"month\" : 9 }, \"value\" : 320 }\n\nVous remarquerez que nous n’avons pas besoin de relancer le calcul à chaque nouvelle demande puisque la collection de sortie est désormais consultable très facilement.\n\nMaintenant optimisons un peu cela.\n\nOn remarque très rapidement que recalculer systématiquement pour les mois passés n’a aucun sens puisque ces données ne peuvent plus changer. Nous allons donc utiliser un MapReduce incrémental.\n\nPour cela, il vous suffit d’appliquer deux options supplémentaires à votre commande :\n\ndb.accounts.mapReduce( map , reduce , {\nout : { merge: \"account\\_stats\" },\nquery : { \\_id: { $gt: objectIdWithTimestamp(2013\u002F09\u002F01') } },\n} )\n\nIci nous avons utilisé deux astuces.\n\nPar défaut, le résultat d’un map reduce remplace toutes les données présentes dans la collection de sortie.\n\nMais nous pouvons préciser le paramètre merge pour que les résultats soient fusionnés avec des résultats déjà présents.\n\nCela va nous permettre de n’ajouter que les résultats concernant les derniers mois.\n\nEt nous allons utiliser le paramètre query pour limiter le jeu de données sur lequel appliquer l’algorithme.\n\nIci nous utilisons une méthode que vous devez définir au préalable permettant de créer un ObjectId à partir d’une date :\n\nfunction objectIdWithTimestamp(timestamp)\n{\n    \u002F\u002F Convert string date to Date object (otherwise assume timestamp is a date)\n    if (typeof(timestamp) == 'string') {\n        timestamp = new Date(timestamp);\n    }\n\n    \u002F\u002F Convert date object to hex seconds since Unix epoch\n    var hexSeconds = Math.floor(timestamp\u002F1000).toString(16);\n\n    \u002F\u002F Create an ObjectId with that hex timestamp\n    var constructedObjectId = ObjectId(hexSeconds + \"0000000000000000\");\n\n    return constructedObjectId\n}\n\n(source : http:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F8749971\u002Fcan-i-query-mongodb-objectid-by-date)\n\nEt voila, vous avez désormais un mapreduce incrémental. On remarquera quand même que l'utilisation d'une date aurait malgré tout simplifié l'écriture de la query de filtrage mais nous nous en sommes sortis sans champ \"created\".\n\nEt c’est terminé. Nous aurions pu voir encore de multiples choses, comment lancer un MapReduce en Java ou comment faire la même chose avec le framework d’aggrégation de MongoDB. Peut-être une autre fois.\n\nOu bien vous pouvez aussi me contacter pour une formation sur MongoDB si jamais ça vous intéresse ;)\n",readTime:{text:"7 min read",minutes:6.28,time:376800,words:1256}},relatedArticles:[{slug:"curseurs-et-mongodb",description:"A chaque fois que je donne la formation Mongo je reste étonné lors de ce slide (qui fait le parallèle entre les termes utilisé en relationnel et avec ...",id:"1137",title:"Curseurs et Mongodb",date:"2015-01-26",tags:["jongo",k],img:"43c58-slideterminology.jpg",cover:H,path:"\u002Farticles\u002F2015\u002F01\u002F26\u002Fcurseurs-et-mongodb"},{slug:"comparaison-de-moteurs-de-base-de-donnees-pour-du-stockage-de-logs",description:"Il y a un an je m’étais aventuré à tester plusieurs bases Nosql, l’objectif étant pour moi d’apprivoiser les moteurs, de comprendre leurs usages et de...",id:"980",title:"Comparaison de moteurs de base de données pour du stockage de logs",date:"2013-11-05",tags:["bench","cassandra","elasticsearch","logs",k,"mysql"],img:"22faa-mongodb.png",cover:"cover2.jpg",path:"\u002Farticles\u002F2013\u002F11\u002F05\u002Fcomparaison-de-moteurs-de-base-de-donnees-pour-du-stockage-de-logs"},{slug:"recherche-textuelle-avec-mongodb",description:"[![mongo](\u002Fimages\u002Faf912-mongo.jpg)](http:\u002F\u002Feventuallycoding.com\u002Fwp-content\u002Fuploads\u002F2014\u002F01\u002Faf912-mongo.jpg)Il y a maintenant 2 ans nous avions choisi ...",id:"1044",title:"Recherche textuelle avec MongoDB",date:"2014-03-06",tags:[k],img:"af912-mongo.jpg",cover:H,path:"\u002Farticles\u002F2014\u002F03\u002F06\u002Frecherche-textuelle-avec-mongodb"}],_img:{"/_ipx/_/hugo-nb.jpg":"\u002F_nuxt\u002Fimage\u002Fc3e54c.jpg"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a","nofollow","noopener","noreferrer","_blank","mapreduce","mongodb","true",-1,"span","icon","icon-link","li","ObjectId","objectid",2,"MapReduce","comment-nous-laurions-résolu-en-sql-",3,"Comment nous l’aurions résolu en SQL :","comment-nous-pouvons-le-résoudre-avec-mongodb","Comment nous pouvons le résoudre avec MongoDB","h2","img","h3","br","strong","http:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F8749971\u002Fcan-i-query-mongodb-objectid-by-date","2022-05-22T13:41:26.747Z","cover1.jpg")));